{
  "Code":{
    "ga.duacord.http.Main":"local Logger = Import(\"nl.cubic-inc.logger.Main\")\n\nif FS.existsSync(\"./HTTP-Key.dat\") == false then\n  print(\"Downloading SSH key (This only happens on the first run)\")\n  local Commands = {\n    [\"Windows\"] = \"PowerShell -Command Invoke-WebRequest http://github.com/luvit/lit/blob/master/deps/secure-socket/root_ca.dat?raw=true -o HTTP-Key.dat\",\n    [\"OSX\"] = \"curl -L http://github.com/luvit/lit/blob/master/deps/secure-socket/root_ca.dat?raw=true --output HTTP-Key.dat\"\n  }\n  \n  local Handle = io.popen(Commands[RuntimeOS])\n  Handle:close()  \nend\n\n\nlocal Modules = {\n  [\"base64\"] = Import(\"ga.duacord.http.Libraries.base64\"),\n  [\"coro-channel\"] = Import(\"ga.duacord.http.Libraries.coro-channel\"),\n  [\"coro-http\"] = Import(\"ga.duacord.http.Libraries.coro-http\"),\n  [\"coro-net\"] = Import(\"ga.duacord.http.Libraries.coro-net\"),\n  [\"coro-websocket\"] = Import(\"ga.duacord.http.Libraries.coro-websocket\"),\n  [\"coro-wrapper\"] = Import(\"ga.duacord.http.Libraries.coro-wrapper\"),\n  [\"http-codec\"] = Import(\"ga.duacord.http.Libraries.http-codec\"),\n  [\"sha1\"] = Import(\"ga.duacord.http.Libraries.sha1\"),\n  [\"websocket-codec\"] = Import(\"ga.duacord.http.Libraries.websocket-codec\")\n}\n\nreturn Modules",
    "ga.duacord.http.Libraries.coro-http":"--[[lit-meta\n  name = \"creationix/coro-http\"\n  version = \"3.2.3\"\n  dependencies = {\n    \"creationix/coro-net@3.3.0\",\n    \"luvit/http-codec@3.0.0\"\n  }\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-http.lua\"\n  description = \"An coro style http(s) client and server helper.\"\n  tags = {\"coro\", \"http\"}\n  license = \"MIT\"\n  author = { name = \"Tim Caswell\" }\n]]\n\nlocal httpCodec = Import(\"ga.duacord.http.Libraries.http-codec\")\nlocal net = Import(\"ga.duacord.http.Libraries.coro-net\")\n\nlocal function createServer(host, port, onConnect)\n  return net.createServer({\n    host = host,\n    port = port,\n    encoder = httpCodec.encoder,\n    decoder = httpCodec.decoder,\n  }, function (read, write, socket)\n    for head in read do\n      local parts = {}\n      for part in read do\n        if #part > 0 then\n          parts[#parts + 1] = part\n        else\n          break\n        end\n      end\n      local body = table.concat(parts)\n      head, body = onConnect(head, body, socket)\n      write(head)\n      if body then write(body) end\n      write(\"\")\n      if not head.keepAlive then break end\n    end\n    write()\n  end)\nend\n\nlocal function parseUrl(url)\n  local protocol, host, hostname, port, path = url:match(\"^(https?:)//(([^/:]+):?([0-9]*))(/?.*)$\")\n  if not protocol then error(\"Not a valid http url: \" .. url) end\n  local tls = protocol == \"https:\"\n  port = port and tonumber(port) or (tls and 443 or 80)\n  if path == \"\" then path = \"/\" end\n  return {\n    tls = tls,\n    host = host,\n    hostname = hostname,\n    port = port,\n    path = path\n  }\nend\n\nlocal connections = {}\n\nlocal function getConnection(host, port, tls, timeout)\n  for i = #connections, 1, -1 do\n    local connection = connections[i]\n    if connection.host == host and connection.port == port and connection.tls == tls then\n      table.remove(connections, i)\n      -- Make sure the connection is still alive before reusing it.\n      if not connection.socket:is_closing() then\n        connection.reused = true\n        connection.socket:ref()\n        return connection\n      end\n    end\n  end\n  local read, write, socket, updateDecoder, updateEncoder = assert(net.connect {\n    host = host,\n    port = port,\n    tls = tls,\n    timeout = timeout,\n    encoder = httpCodec.encoder,\n    decoder = httpCodec.decoder\n  })\n  return {\n    socket = socket,\n    host = host,\n    port = port,\n    tls = tls,\n    read = read,\n    write = write,\n    updateEncoder = updateEncoder,\n    updateDecoder = updateDecoder,\n    reset = function ()\n      -- This is called after parsing the response head from a HEAD request.\n      -- If you forget, the codec might hang waiting for a body that doesn't exist.\n      updateDecoder(httpCodec.decoder())\n    end\n  }\nend\n\nlocal function saveConnection(connection)\n  if connection.socket:is_closing() then return end\n  connections[#connections + 1] = connection\n  connection.socket:unref()\nend\n\nlocal function request(method, url, headers, body, customOptions)\n  -- customOptions = { timeout = number, followRedirects = boolean }\n  local options = {}\n  if type(customOptions) == \"number\" then\n    -- Ensure backwards compatibility, where customOptions used to just be timeout\n    options.timeout = customOptions\n  else\n    options = customOptions or {}\n  end\n  options.followRedirects = options.followRedirects == nil and true or options.followRedirects -- Follow any redirects, Default: true\n\n  local uri = parseUrl(url)\n  local connection = getConnection(uri.hostname, uri.port, uri.tls, options.timeout)\n  local read = connection.read\n  local write = connection.write\n\n  local req = {\n    method = method,\n    path = uri.path,\n  }\n  local contentLength\n  local chunked\n  local hasHost = false\n  if headers then\n    for i = 1, #headers do\n      local key, value = unpack(headers[i])\n      key = key:lower()\n      if key == \"content-length\" then\n        contentLength = value\n      elseif key == \"content-encoding\" and value:lower() == \"chunked\" then\n        chunked = true\n      elseif key == \"host\" then\n        hasHost = true\n      end\n      req[#req + 1] = headers[i]\n    end\n  end\n  if not hasHost then\n    req[#req + 1] = {\"Host\", uri.host}\n  end\n\n\n  if type(body) == \"string\" then\n    if not chunked and not contentLength then\n      req[#req + 1] = {\"Content-Length\", #body}\n    end\n  end\n\n  write(req)\n  if body then write(body) end\n  local res = read()\n  if not res then\n    if not connection.socket:is_closing() then\n      connection.socket:close()\n    end\n    -- If we get an immediate close on a reused socket, try again with a new socket.\n    -- TODO: think about if this could resend requests with side effects and cause\n    -- them to double execute in the remote server.\n    if connection.reused then\n      return request(method, url, headers, body)\n    end\n    error(\"Connection closed\")\n  end\n\n  body = {}\n  if req.method == \"HEAD\" then\n    connection.reset()\n  else\n    while true do\n      local item = read()\n      if not item then\n        res.keepAlive = false\n        break\n      end\n      if #item == 0 then\n        break\n      end\n      body[#body + 1] = item\n    end\n  end\n\n  if res.keepAlive then\n    saveConnection(connection)\n  else\n    write()\n  end\n\n  -- Follow redirects\n  if method == \"GET\" and (res.code == 302 or res.code == 307) and options.followRedirects then\n    for i = 1, #res do\n      local key, location = unpack(res[i])\n      if key:lower() == \"location\" then\n        return request(method, location, headers)\n      end\n    end\n  end\n\n  return res, table.concat(body)\nend\n\nreturn {\n  createServer = createServer,\n  parseUrl = parseUrl,\n  getConnection = getConnection,\n  saveConnection = saveConnection,\n  request = request,\n}",
    "ga.duacord.http.Test":"local Package = {}\n\nLoadPackage(\"./Libraries/Logger.dua\")\n\n\n\nfunction Package.OnInitialize()\n\n  local Logger = Import(\"nl.cubic-inc.logger.Main\")\n  local Http = Import(\"ga.duacord.http.Main\")\n\n  Logger:Info(\"Package loaded!\")\n\n  p(Http[\"coro-http\"].request(\"GET\", \"https://google.nl\"))\n\nend\n\nreturn Package\n",
    "ga.duacord.http.Libraries.secure-socket.biowrap":"--[[\n\nCopyright 2016 The Luvit Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS-IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n--]]\nlocal openssl = require('openssl')\n\n-- writeCipher is called when ssl needs something written on the socket\n-- handshakeComplete is called when the handhake is complete and it's safe\n-- onPlain is called when plaintext comes out.\nreturn function (ctx, isServer, socket, handshakeComplete, servername)\n\n  local bin, bout = openssl.bio.mem(8192), openssl.bio.mem(8192)\n  local ssl = ctx:ssl(bin, bout, isServer)\n\n  if not isServer and servername then\n      ssl:set('hostname', servername)\n  end\n\n  local ssocket = {tls=true}\n  local onPlain\n\n  local function flush(callback)\n    local chunks = {}\n    local i = 0\n    while bout:pending() > 0 do\n      i = i + 1\n      chunks[i] = bout:read()\n    end\n    if i == 0 then\n      if callback then callback() end\n      return true\n    end\n    return socket:write(chunks, callback)\n  end\n\n  local function handshake(callback)\n    if ssl:handshake() then\n      local success, result = ssl:getpeerverification()\n      socket:read_stop()\n      if not success and result then\n        handshakeComplete(\"Error verifying peer: \" .. result[1].error_string)\n      end\n      handshakeComplete(nil, ssocket)\n    end\n    return flush(callback)\n  end\n\n  local function onCipher(err, data)\n    if not onPlain then\n      if err or not data then\n        return handshakeComplete(err or \"Peer aborted the SSL handshake\", data)\n      end\n      bin:write(data)\n      return handshake()\n    end\n    if err or not data then\n      return onPlain(err, data)\n    end\n    bin:write(data)\n    while  true do\n      local plain = ssl:read()\n      if not plain then break end\n      onPlain(nil, plain)\n    end\n  end\n\n  -- When requested to start reading, start the real socket and setup\n  -- onPlain handler\n  function ssocket.read_start(_, onRead)\n    onPlain = onRead\n    return socket:read_start(onCipher)\n  end\n\n  -- When requested to write plain data, encrypt it and write to socket\n  function ssocket.write(_, plain, callback)\n    ssl:write(plain)\n    return flush(callback)\n  end\n\n  function ssocket.shutdown(_, ...)\n    return socket:shutdown(...)\n  end\n  function ssocket.read_stop(_, ...)\n    return socket:read_stop(...)\n  end\n  function ssocket.is_closing(_, ...)\n    return socket:is_closing(...)\n  end\n  function ssocket.close(_, ...)\n    return socket:close(...)\n  end\n  function ssocket.unref(_, ...)\n    return socket:unref(...)\n  end\n  function ssocket.ref(_, ...)\n    return socket:ref(...)\n  end\n\n  handshake()\n  socket:read_start(onCipher)\n\nend\n",
    "ga.duacord.http.Libraries.sha1":"--[[lit-meta\n  name = \"creationix/sha1\"\n  version = \"1.0.4\"\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/sha1.lua\"\n  description = \"Pure Lua implementation of SHA1 using bitop\"\n  authors = {\n    \"Tim Caswell\"\n  }\n]]\n\n-- http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA_All.pdf\n\nlocal bit = require('bit')\nlocal band = bit.band\nlocal bor = bit.bor\nlocal bxor = bit.bxor\nlocal lshift = bit.lshift\nlocal rshift = bit.rshift\nlocal rol = bit.rol\nlocal tobit = bit.tobit\nlocal tohex = bit.tohex\n\nlocal byte = string.byte\nlocal concat = table.concat\nlocal floor = table.floor\n\nlocal hasFFi, ffi = pcall(require, \"ffi\")\nlocal newBlock = hasFFi and function ()\n  return ffi.new(\"uint32_t[80]\")\nend or function ()\n  local t = {}\n  for i = 0, 79 do\n    t[i] = 0\n  end\n  return t\nend\n\nlocal shared = newBlock()\n\nlocal function unsigned(n)\n  return n < 0 and (n + 0x100000000) or n\nend\n\nlocal function create(sync)\n  local h0 = 0x67452301\n  local h1 = 0xEFCDAB89\n  local h2 = 0x98BADCFE\n  local h3 = 0x10325476\n  local h4 = 0xC3D2E1F0\n  -- The first 64 bytes (16 words) is the data chunk\n  local W = sync and shared or newBlock()\n  local offset = 0\n  local shift = 24\n  local totalLength = 0\n\n  local update, write, processBlock, digest\n\n  -- The user gave us more data.  Store it!\n  function update(chunk)\n    local length = #chunk\n    totalLength = totalLength + length * 8\n    for i = 1, length do\n      write(byte(chunk, i))\n    end\n  end\n\n  function write(data)\n    W[offset] = bor(W[offset], lshift(band(data, 0xff), shift))\n    if shift > 0 then\n      shift = shift - 8\n    else\n      offset = offset + 1\n      shift = 24\n    end\n    if offset == 16 then\n      return processBlock()\n    end\n  end\n\n  -- No more data will come, pad the block, process and return the result.\n  function digest()\n    -- Pad\n    write(0x80)\n    if offset > 14 or (offset == 14 and shift < 24) then\n      processBlock()\n    end\n    offset = 14\n    shift = 24\n\n    -- 64-bit length big-endian\n    write(0x00) -- numbers this big aren't accurate in lua anyway\n    write(0x00) -- ..So just hard-code to zero.\n    write(totalLength > 0xffffffffff and floor(totalLength / 0x10000000000) or 0x00)\n    write(totalLength > 0xffffffff and floor(totalLength / 0x100000000) or 0x00)\n    for s = 24, 0, -8 do\n      write(rshift(totalLength, s))\n    end\n\n    -- At this point one last processBlock() should trigger and we can pull out the result.\n    return concat {\n      tohex(h0),\n      tohex(h1),\n      tohex(h2),\n      tohex(h3),\n      tohex(h4)\n    }\n  end\n\n  -- We have a full block to process.  Let's do it!\n  function processBlock()\n\n    -- Extend the sixteen 32-bit words into eighty 32-bit words:\n    for i = 16, 79, 1 do\n      W[i] =\n        rol(bxor(W[i - 3], W[i - 8], W[i - 14], W[i - 16]), 1)\n    end\n\n    -- print(\"Block Contents:\")\n    -- for i = 0, 15 do\n    --   print(string.format(\"  W[%d] = %s\", i, tohex(W[i])))\n    -- end\n    -- print()\n\n    -- Initialize hash value for this chunk:\n    local a = h0\n    local b = h1\n    local c = h2\n    local d = h3\n    local e = h4\n    local f, k\n\n    -- print(\"         A         B         C         D         E\")\n    -- local format =\n    --   \"t=%02d: %s  %s  %s  %s  %s\"\n    -- Main loop:\n    for t = 0, 79 do\n      if t < 20 then\n        f = bxor(d, band(b, bxor(c, d)))\n        k = 0x5A827999\n      elseif t < 40 then\n        f = bxor(b, c, d)\n        k = 0x6ED9EBA1\n      elseif t < 60 then\n        f = bor(band(b, c), (band(d, bor(b, c))))\n        k = 0x8F1BBCDC\n      else\n        f = bxor(b, c, d)\n        k = 0xCA62C1D6\n      end\n      e, d, c, b, a =\n        d,\n        c,\n        rol(b, 30),\n        a,\n        tobit(\n          unsigned(rol(a, 5)) +\n          unsigned(f) +\n          unsigned(e) +\n          unsigned(k) +\n          W[t]\n        )\n      -- print(string.format(format, t, tohex(a), tohex(b), tohex(c), tohex(d), tohex(e)))\n    end\n\n    -- Add this chunk's hash to result so far:\n    h0 = tobit(unsigned(h0) + a)\n    h1 = tobit(unsigned(h1) + b)\n    h2 = tobit(unsigned(h2) + c)\n    h3 = tobit(unsigned(h3) + d)\n    h4 = tobit(unsigned(h4) + e)\n\n    -- The block is now reusable.\n    offset = 0\n    for i = 0, 15 do\n      W[i] = 0\n    end\n  end\n\n  return {\n    update = update,\n    digest = digest\n  }\n\nend\n\nreturn function (buffer)\n  -- Pass in false or nil to get a streaming interface.\n  if not buffer then\n    return create(false)\n  end\n  local shasum = create(true)\n  shasum.update(buffer)\n  return shasum.digest()\nend",
    "ga.duacord.http.Libraries.secure-socket.package":"return {\n  name = \"luvit/secure-socket\",\n  version = \"1.2.3\",\n  homepage = \"https://github.com/luvit/luvit/blob/master/deps/secure-socket\",\n  description = \"Wrapper for luv streams to apply ssl/tls\",\n  dependencies = {\n    \"luvit/resource@2.1.0\"\n  },\n  tags = {\"ssl\", \"socket\",\"tls\"},\n  license = \"Apache 2\",\n  author = { name = \"Tim Caswell\" }\n}\n",
    "ga.duacord.http.Libraries.http-codec":"--[[\nCopyright 2014-2015 The Luvit Authors. All Rights Reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS-IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n--]]\n\n--[[lit-meta\n  name = \"luvit/http-codec\"\n  version = \"3.0.6\"\n  homepage = \"https://github.com/luvit/luvit/blob/master/deps/http-codec.lua\"\n  description = \"A simple pair of functions for converting between hex and raw strings.\"\n  tags = {\"codec\", \"http\"}\n  license = \"Apache 2\"\n  author = { name = \"Tim Caswell\" }\n]]\n\nlocal sub = string.sub\nlocal gsub = string.gsub\nlocal lower = string.lower\nlocal find = string.find\nlocal format = string.format\nlocal concat = table.concat\nlocal match = string.match\n\nlocal STATUS_CODES = {\n  [100] = 'Continue',\n  [101] = 'Switching Protocols',\n  [102] = 'Processing',                 -- RFC 2518, obsoleted by RFC 4918\n  [200] = 'OK',\n  [201] = 'Created',\n  [202] = 'Accepted',\n  [203] = 'Non-Authoritative Information',\n  [204] = 'No Content',\n  [205] = 'Reset Content',\n  [206] = 'Partial Content',\n  [207] = 'Multi-Status',               -- RFC 4918\n  [300] = 'Multiple Choices',\n  [301] = 'Moved Permanently',\n  [302] = 'Moved Temporarily',\n  [303] = 'See Other',\n  [304] = 'Not Modified',\n  [305] = 'Use Proxy',\n  [307] = 'Temporary Redirect',\n  [400] = 'Bad Request',\n  [401] = 'Unauthorized',\n  [402] = 'Payment Required',\n  [403] = 'Forbidden',\n  [404] = 'Not Found',\n  [405] = 'Method Not Allowed',\n  [406] = 'Not Acceptable',\n  [407] = 'Proxy Authentication Required',\n  [408] = 'Request Time-out',\n  [409] = 'Conflict',\n  [410] = 'Gone',\n  [411] = 'Length Required',\n  [412] = 'Precondition Failed',\n  [413] = 'Request Entity Too Large',\n  [414] = 'Request-URI Too Large',\n  [415] = 'Unsupported Media Type',\n  [416] = 'Requested Range Not Satisfiable',\n  [417] = 'Expectation Failed',\n  [418] = \"I'm a teapot\",                       -- RFC 2324\n  [422] = 'Unprocessable Entity',               -- RFC 4918\n  [423] = 'Locked',                             -- RFC 4918\n  [424] = 'Failed Dependency',                  -- RFC 4918\n  [425] = 'Unordered Collection',               -- RFC 4918\n  [426] = 'Upgrade Required',                   -- RFC 2817\n  [428] = 'Precondition Required',              -- RFC 6585\n  [429] = 'Too Many Requests',                  -- RFC 6585\n  [431] = 'Request Header Fields Too Large',    -- RFC 6585\n  [500] = 'Internal Server Error',\n  [501] = 'Not Implemented',\n  [502] = 'Bad Gateway',\n  [503] = 'Service Unavailable',\n  [504] = 'Gateway Time-out',\n  [505] = 'HTTP Version not supported',\n  [506] = 'Variant Also Negotiates',            -- RFC 2295\n  [507] = 'Insufficient Storage',               -- RFC 4918\n  [509] = 'Bandwidth Limit Exceeded',\n  [510] = 'Not Extended',                       -- RFC 2774\n  [511] = 'Network Authentication Required'     -- RFC 6585\n}\n\nlocal function encoder()\n\n  local mode\n  local encodeHead, encodeRaw, encodeChunked\n\n  function encodeHead(item)\n    if not item or item == \"\" then\n      return item\n    elseif not (type(item) == \"table\") then\n      error(\"expected a table but got a \" .. type(item) .. \" when encoding data\")\n    end\n    local head, chunkedEncoding\n    local version = item.version or 1.1\n    if item.method then\n      local path = item.path\n      assert(path and #path > 0, \"expected non-empty path\")\n      head = { item.method .. ' ' .. item.path .. ' HTTP/' .. version .. '\\r\\n' }\n    else\n      local reason = item.reason or STATUS_CODES[item.code]\n      head = { 'HTTP/' .. version .. ' ' .. item.code .. ' ' .. reason .. '\\r\\n' }\n    end\n    for i = 1, #item do\n      local key, value = unpack(item[i])\n      local lowerKey = lower(key)\n      if lowerKey == \"transfer-encoding\" then\n        chunkedEncoding = lower(value) == \"chunked\"\n      end\n      value = gsub(tostring(value), \"[\\r\\n]+\", \" \")\n      head[#head + 1] = key .. ': ' .. tostring(value) .. '\\r\\n'\n    end\n    head[#head + 1] = '\\r\\n'\n\n    mode = chunkedEncoding and encodeChunked or encodeRaw\n    return concat(head)\n  end\n\n  function encodeRaw(item)\n    if type(item) ~= \"string\" then\n      mode = encodeHead\n      return encodeHead(item)\n    end\n    return item\n  end\n\n  function encodeChunked(item)\n    if type(item) ~= \"string\" then\n      mode = encodeHead\n      local extra = encodeHead(item)\n      if extra then\n        return \"0\\r\\n\\r\\n\" .. extra\n      else\n        return \"0\\r\\n\\r\\n\"\n      end\n    end\n    if #item == 0 then\n      mode = encodeHead\n    end\n    return format(\"%x\", #item) .. \"\\r\\n\" .. item .. \"\\r\\n\"\n  end\n\n  mode = encodeHead\n  return function (item)\n    return mode(item)\n  end\nend\n\nlocal function decoder()\n\n  -- This decoder is somewhat stateful with 5 different parsing states.\n  local decodeHead, decodeEmpty, decodeRaw, decodeChunked, decodeCounted\n  local mode -- state variable that points to various decoders\n  local bytesLeft -- For counted decoder\n\n  -- This state is for decoding the status line and headers.\n  function decodeHead(chunk, index)\n    if not chunk or index > #chunk then return end\n\n    local _, last = find(chunk, \"\\r?\\n\\r?\\n\", index)\n    -- First make sure we have all the head before continuing\n    if not last then\n      if (#chunk - index) <= 8 * 1024 then return end\n      -- But protect against evil clients by refusing heads over 8K long.\n      error(\"entity too large\")\n    end\n\n    -- Parse the status/request line\n    local head = {}\n    local _, offset\n    local version\n    _, offset, version, head.code, head.reason =\n      find(chunk, \"^HTTP/(%d%.%d) (%d+) ([^\\r\\n]*)\\r?\\n\", index)\n    if offset then\n      head.code = tonumber(head.code)\n    else\n      _, offset, head.method, head.path, version =\n        find(chunk, \"^(%u+) ([^ ]+) HTTP/(%d%.%d)\\r?\\n\", index)\n      if not offset then\n        error(\"expected HTTP data\")\n      end\n    end\n    version = tonumber(version)\n    head.version = version\n    head.keepAlive = version > 1.0\n\n    -- We need to inspect some headers to know how to parse the body.\n    local contentLength\n    local chunkedEncoding\n\n    -- Parse the header lines\n    while true do\n      local key, value\n      _, offset, key, value = find(chunk, \"^([^:\\r\\n]+): *([^\\r\\n]*)\\r?\\n\", offset + 1)\n      if not offset then break end\n      local lowerKey = lower(key)\n\n      -- Inspect a few headers and remember the values\n      if lowerKey == \"content-length\" then\n        contentLength = tonumber(value)\n      elseif lowerKey == \"transfer-encoding\" then\n        chunkedEncoding = lower(value) == \"chunked\"\n      elseif lowerKey == \"connection\" then\n        head.keepAlive = lower(value) == \"keep-alive\"\n      end\n      head[#head + 1] = {key, value}\n    end\n\n    if head.keepAlive and (not (chunkedEncoding or (contentLength and contentLength > 0)))\n       or (head.method == \"GET\" or head.method == \"HEAD\") then\n      mode = decodeEmpty\n    elseif chunkedEncoding then\n      mode = decodeChunked\n    elseif contentLength then\n      bytesLeft = contentLength\n      mode = decodeCounted\n    elseif not head.keepAlive then\n      mode = decodeRaw\n    end\n    return head, last + 1\n\n  end\n\n  -- This is used for inserting a single empty string into the output string for known empty bodies\n  function decodeEmpty(chunk, index)\n    mode = decodeHead\n    return \"\", index\n  end\n\n  function decodeRaw(chunk, index)\n    if #chunk < index then return end\n    return sub(chunk, index)\n  end\n\n  function decodeChunked(chunk, index)\n    local len, term\n    len, term = match(chunk, \"^(%x+)(..)\", index)\n    if not len then return end\n    if term ~= \"\\r\\n\" then\n      -- Wait for full chunk-size\\r\\n header\n      if #chunk < 18 then return end\n      -- But protect against evil clients by refusing chunk-sizes longer than 16 hex digits.\n      error(\"chunk-size field too large\")\n    end\n    index = index + #len + 2\n    local offset = index - 1\n    local length = tonumber(len, 16)\n    if #chunk < offset + length + 2 then return end\n    if length == 0 then\n      mode = decodeHead\n    end\n    assert(sub(chunk, index + length, index + length + 1) == \"\\r\\n\")\n    local piece = sub(chunk, index, index + length - 1)\n    return piece, index + length + 2\n  end\n\n  function decodeCounted(chunk, index)\n    if bytesLeft == 0 then\n      mode = decodeEmpty\n      return mode(chunk, index)\n    end\n    local offset = index - 1\n    local length = #chunk - offset\n    -- Make sure we have at least one byte to process\n    if length == 0 then return end\n\n    -- If there isn't enough data left, emit what we got so far\n    if length < bytesLeft then\n      bytesLeft = bytesLeft - length\n      return sub(chunk, index)\n    end\n\n    mode = decodeEmpty\n    return sub(chunk, index, offset + bytesLeft), index + bytesLeft\n  end\n\n  -- Switch between states by changing which decoder mode points to\n  mode = decodeHead\n  return function (chunk, index)\n    return mode(chunk, index)\n  end\n\nend\n\nreturn {\n  encoder = encoder,\n  decoder = decoder,\n}",
    "ga.duacord.http.Libraries.base64":"--[[lit-meta\n  name = \"creationix/base64\"\n  description = \"A pure lua implemention of base64 using bitop\"\n  tags = {\"crypto\", \"base64\", \"bitop\"}\n  version = \"2.0.0\"\n  license = \"MIT\"\n  author = { name = \"Tim Caswell\" }\n]]\n\nlocal bit = require 'bit'\nlocal rshift = bit.rshift\nlocal lshift = bit.lshift\nlocal bor = bit.bor\nlocal band = bit.band\nlocal char = string.char\nlocal byte = string.byte\nlocal concat = table.concat\nlocal codes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\n-- Loop over input 3 bytes at a time\n-- a,b,c are 3 x 8-bit numbers\n-- they are encoded into groups of 4 x 6-bit numbers\n-- aaaaaa aabbbb bbbbcc cccccc\n-- if there is no c, then pad the 4th with =\n-- if there is also no b then pad the 3rd with =\nlocal function base64Encode(str)\n  local parts = {}\n  local j = 1\n  for i = 1, #str, 3 do\n    local a, b, c = byte(str, i, i + 2)\n    parts[j] = char(\n      -- Higher 6 bits of a\n      byte(codes, rshift(a, 2) + 1),\n      -- Lower 2 bits of a + high 4 bits of b\n      byte(codes, bor(\n        lshift(band(a, 3), 4),\n        b and rshift(b, 4) or 0\n      ) + 1),\n      -- Low 4 bits of b + High 2 bits of c\n      b and byte(codes, bor(\n        lshift(band(b, 15), 2),\n        c and rshift(c, 6) or 0\n      ) + 1) or 61, -- 61 is '='\n      -- Lower 6 bits of c\n      c and byte(codes, band(c, 63) + 1) or 61 -- 61 is '='\n    )\n    j = j + 1\n  end\n  return concat(parts)\nend\n\n-- Reverse map from character code to 6-bit integer\nlocal map = {}\nfor i = 1, #codes do\n  map[byte(codes, i)] = i - 1\nend\n\n-- loop over input 4 characters at a time\n-- The characters are mapped to 4 x 6-bit integers a,b,c,d\n-- They need to be reassalbled into 3 x 8-bit bytes\n-- aaaaaabb bbbbcccc ccdddddd\n-- if d is padding then there is no 3rd byte\n-- if c is padding then there is no 2nd byte\nlocal function base64Decode(data)\n  local bytes = {}\n  local j = 1\n  for i = 1, #data, 4 do\n    local a = map[byte(data, i)]\n    local b = map[byte(data, i + 1)]\n    local c = map[byte(data, i + 2)]\n    local d = map[byte(data, i + 3)]\n\n    -- higher 6 bits are the first char\n    -- lower 2 bits are upper 2 bits of second char\n    bytes[j] = char(bor(lshift(a, 2), rshift(b, 4)))\n\n    -- if the third char is not padding, we have a second byte\n    if c < 64 then\n      -- high 4 bits come from lower 4 bits in b\n      -- low 4 bits come from high 4 bits in c\n      bytes[j + 1] = char(bor(lshift(band(b, 0xf), 4), rshift(c, 2)))\n\n      -- if the fourth char is not padding, we have a third byte\n      if d < 64 then\n        -- Upper 2 bits come from Lower 2 bits of c\n        -- Lower 6 bits come from d\n        bytes[j + 2] = char(bor(lshift(band(c, 3), 6), d))\n      end\n    end\n    j = j + 3\n  end\n  return concat(bytes)\nend\n\nassert(base64Encode(\"\") == \"\")\nassert(base64Encode(\"f\") == \"Zg==\")\nassert(base64Encode(\"fo\") == \"Zm8=\")\nassert(base64Encode(\"foo\") == \"Zm9v\")\nassert(base64Encode(\"foob\") == \"Zm9vYg==\")\nassert(base64Encode(\"fooba\") == \"Zm9vYmE=\")\nassert(base64Encode(\"foobar\") == \"Zm9vYmFy\")\n\nassert(base64Decode(\"\") == \"\")\nassert(base64Decode(\"Zg==\") == \"f\")\nassert(base64Decode(\"Zm8=\") == \"fo\")\nassert(base64Decode(\"Zm9v\") == \"foo\")\nassert(base64Decode(\"Zm9vYg==\") == \"foob\")\nassert(base64Decode(\"Zm9vYmE=\") == \"fooba\")\nassert(base64Decode(\"Zm9vYmFy\") == \"foobar\")\n\nreturn {\n  encode = base64Encode,\n  decode = base64Decode,\n}",
    "ga.duacord.http.Libraries.secure-socket.init":"--[[\n\nCopyright 2016 The Luvit Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS-IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n--]]\nlocal getContext = Import(\"ga.duacord.http.Libraries.secure-socket.context\")\nlocal bioWrap = Import(\"ga.duacord.http.Libraries.secure-socket.biowrap\")\n\nlocal function assertResume(thread, ...)\n  local success, err = coroutine.resume(thread, ...)\n  if not success then\n    error(debug.traceback(thread, err), 0)\n  end\nend\n\nreturn function (socket, options, callback)\n  if options == true then options = {} end\n  local ctx = getContext(options)\n  local thread\n  if not callback then\n    thread = coroutine.running()\n  end\n  bioWrap(ctx, options.server, socket, callback or function (err, ssocket)\n    return assertResume(thread, ssocket, err)\nend, options.servername)\n  if not callback then\n    return coroutine.yield()\n  end\nend\n",
    "ga.duacord.http.Libraries.coro-websocket":"--[[lit-meta\n  name = \"creationix/coro-websocket\"\n  version = \"3.1.1\"\n  dependencies = {\n    \"luvit/http-codec@3.0.0\",\n    \"creationix/websocket-codec@3.0.0\",\n    \"creationix/coro-net@3.3.0\",\n  }\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-websocket.lua\"\n  description = \"Websocket helpers assuming coro style I/O.\"\n  tags = {\"coro\", \"websocket\"}\n  license = \"MIT\"\n  author = { name = \"Tim Caswell\" }\n]]\n\nlocal uv = require('uv')\nlocal httpCodec = Import(\"ga.duacord.http.Libraries.http-codec\")\nlocal websocketCodec = Import(\"ga.duacord.http.Libraries.websocket-codec\")\nlocal net = Import(\"ga.duacord.http.Libraries.coro-net\")\n\nlocal function parseUrl(url)\n  local protocol, host, port, pathname = string.match(url, \"^(wss?)://([^:/]+):?(%d*)(/?[^#?]*)\")\n  local tls\n  if protocol == \"ws\" then\n    port = tonumber(port) or 80\n    tls = false\n  elseif protocol == \"wss\" then\n    port = tonumber(port) or 443\n    tls = true\n  else\n    return nil, \"Sorry, only ws:// or wss:// protocols supported\"\n  end\n  return {\n    host = host,\n    port = port,\n    tls = tls,\n    pathname = pathname\n  }\nend\n\nlocal function wrapIo(rawRead, rawWrite, options)\n\n  local closeSent = false\n\n  local timer\n\n  local function cleanup()\n    if timer then\n      if not timer:is_closing() then\n        timer:close()\n      end\n      timer = nil\n    end\n  end\n\n  local function write(message)\n    if message then\n      message.mask = options.mask\n      if message.opcode == 8 then\n        closeSent = true\n        rawWrite(message)\n        cleanup()\n        return rawWrite()\n      end\n    else\n      if not closeSent then\n        return write({\n          opcode = 8,\n          payload = \"\"\n        })\n      end\n    end\n    return rawWrite(message)\n  end\n\n\n  local function read()\n    while true do\n      local message = rawRead()\n      if not message then\n        return cleanup()\n      end\n      if message.opcode < 8 then\n        return message\n      end\n      if not closeSent then\n        if message.opcode == 8 then\n          write {\n            opcode = 8,\n            payload = message.payload\n          }\n        elseif message.opcode == 9 then\n          write {\n            opcode = 10,\n            payload = message.payload\n          }\n        end\n        return message\n      end\n    end\n  end\n\n  if options.heartbeat then\n    local interval = options.heartbeat\n    timer = uv.new_timer()\n    timer:unref()\n    timer:start(interval, interval, function ()\n      coroutine.wrap(function ()\n        local success, err = write {\n          opcode = 10,\n          payload = \"\"\n        }\n        if not success then\n          timer:close()\n          print(err)\n        end\n      end)()\n    end)\n  end\n\n  return read, write\nend\n\n-- options table to configure connection\n--   options.path\n--   options.host\n--   options.port\n--   options.tls\n--   options.pathname\n--   options.subprotocol\n--   options.headers (as list of header/value pairs)\n--   options.timeout\n--   options.heartbeat\n-- returns res, read, write (res.socket has socket)\nlocal function connect(options)\n  options = options or {}\n  local config = {\n    path = options.path,\n    host = options.host,\n    port = options.port,\n    tls = options.tls,\n    encoder = httpCodec.encoder,\n    decoder = httpCodec.decoder,\n  }\n  local read, write, socket, updateDecoder, updateEncoder\n    = net.connect(config, options.timeout or 10000)\n  if not read then\n    return nil, write\n  end\n\n  local res\n\n  local success, err = websocketCodec.handshake({\n    host = options.host,\n    path = options.pathname,\n    protocol = options.subprotocol\n  }, function (req)\n    local headers = options.headers\n    if headers then\n      for i = 1, #headers do\n        req[#req + 1] = headers[i]\n      end\n    end\n    write(req)\n    res = read()\n    if not res then error(\"Missing server response\") end\n    if res.code == 400 then\n      -- p { req = req, res = res }\n      local reason = read() or res.reason\n      error(\"Invalid request: \" .. reason)\n    end\n    return res\n  end)\n  if not success then\n    return nil, err\n  end\n\n  -- Upgrade the protocol to websocket\n  updateDecoder(websocketCodec.decode)\n  updateEncoder(websocketCodec.encode)\n\n  read, write = wrapIo(read, write, {\n    mask = true,\n    heartbeat = options.heartbeat\n  })\n\n  res.socket = socket\n  return res, read, write\n\nend\n\nreturn {\n  parseUrl = parseUrl,\n  wrapIo = wrapIo,\n  connect = connect,\n}",
    "ga.duacord.http.Libraries.websocket-codec":"--[[lit-meta\n  name = \"creationix/websocket-codec\"\n  description = \"A codec implementing websocket framing and helpers for handshakeing\"\n  version = \"3.0.2\"\n  dependencies = {\n    \"creationix/base64@2.0.0\",\n    \"creationix/sha1@1.0.0\",\n  }\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/websocket-codec.lua\"\n  tags = {\"http\", \"websocket\", \"codec\"}\n  license = \"MIT\"\n  author = { name = \"Tim Caswell\" }\n]]\n\nlocal base64 = Import(\"ga.duacord.http.Libraries.base64\").encode\nlocal sha1 = Import(\"ga.duacord.http.Libraries.sha1\")\nlocal bit = require('bit')\n\nlocal band = bit.band\nlocal bor = bit.bor\nlocal bxor = bit.bxor\nlocal rshift = bit.rshift\nlocal lshift = bit.lshift\nlocal char = string.char\nlocal byte = string.byte\nlocal sub = string.sub\nlocal gmatch = string.gmatch\nlocal lower = string.lower\nlocal gsub = string.gsub\nlocal concat = table.concat\nlocal floor = math.floor\nlocal random = math.random\n\nlocal function rand4()\n  -- Generate 32 bits of pseudo random data\n  local num = floor(random() * 0x100000000)\n  -- Return as a 4-byte string\n  return char(\n    rshift(num, 24),\n    band(rshift(num, 16), 0xff),\n    band(rshift(num, 8), 0xff),\n    band(num, 0xff)\n  )\nend\n\nlocal function applyMask(data, mask)\n  local bytes = {\n    [0] = byte(mask, 1),\n    [1] = byte(mask, 2),\n    [2] = byte(mask, 3),\n    [3] = byte(mask, 4)\n  }\n  local out = {}\n  for i = 1, #data do\n    out[i] = char(\n      bxor(byte(data, i), bytes[(i - 1) % 4])\n    )\n  end\n  return concat(out)\nend\n\nlocal function decode(chunk, index)\n  local start = index - 1\n  local length = #chunk - start\n  if length < 2 then return end\n  local second = byte(chunk, start + 2)\n  local len = band(second, 0x7f)\n  local offset\n  if len == 126 then\n    if length < 4 then return end\n    len = bor(\n      lshift(byte(chunk, start + 3), 8),\n      byte(chunk, start + 4))\n    offset = 4\n  elseif len == 127 then\n    if length < 10 then return end\n    len = bor(\n      lshift(byte(chunk, start + 3), 24),\n      lshift(byte(chunk, start + 4), 16),\n      lshift(byte(chunk, start + 5), 8),\n      byte(chunk, start + 6)\n    ) * 0x100000000 + bor(\n      lshift(byte(chunk, start + 7), 24),\n      lshift(byte(chunk, start + 8), 16),\n      lshift(byte(chunk, start + 9), 8),\n      byte(chunk, start + 10)\n    )\n    offset = 10\n  else\n    offset = 2\n  end\n  local mask = band(second, 0x80) > 0\n  if mask then\n    offset = offset + 4\n  end\n  offset = offset + start\n  if #chunk < offset + len then return end\n\n  local first = byte(chunk, start + 1)\n  local payload = sub(chunk, offset + 1, offset + len)\n  assert(#payload == len, \"Length mismatch\")\n  if mask then\n    payload = applyMask(payload, sub(chunk, offset - 3, offset))\n  end\n  return {\n    fin = band(first, 0x80) > 0,\n    rsv1 = band(first, 0x40) > 0,\n    rsv2 = band(first, 0x20) > 0,\n    rsv3 = band(first, 0x10) > 0,\n    opcode = band(first, 0xf),\n    mask = mask,\n    len = len,\n    payload = payload\n  }, offset + len + 1\nend\n\nlocal function encode(item)\n  if type(item) == \"string\" then\n    item = {\n      opcode = 2,\n      payload = item\n    }\n  end\n  local payload = item.payload\n  assert(type(payload) == \"string\", \"payload must be string\")\n  local len = #payload\n  local fin = item.fin\n  if fin == nil then fin = true end\n  local rsv1 = item.rsv1\n  local rsv2 = item.rsv2\n  local rsv3 = item.rsv3\n  local opcode = item.opcode or 2\n  local mask = item.mask\n  local chars = {\n    char(bor(\n      fin and 0x80 or 0,\n      rsv1 and 0x40 or 0,\n      rsv2 and 0x20 or 0,\n      rsv3 and 0x10 or 0,\n      opcode\n    )),\n    char(bor(\n      mask and 0x80 or 0,\n      len < 126 and len or (len < 0x10000) and 126 or 127\n    ))\n  }\n  if len >= 0x10000 then\n    local high = len / 0x100000000\n    chars[3] = char(band(rshift(high, 24), 0xff))\n    chars[4] = char(band(rshift(high, 16), 0xff))\n    chars[5] = char(band(rshift(high, 8), 0xff))\n    chars[6] = char(band(high, 0xff))\n    chars[7] = char(band(rshift(len, 24), 0xff))\n    chars[8] = char(band(rshift(len, 16), 0xff))\n    chars[9] = char(band(rshift(len, 8), 0xff))\n    chars[10] = char(band(len, 0xff))\n  elseif len >= 126 then\n    chars[3] = char(band(rshift(len, 8), 0xff))\n    chars[4] = char(band(len, 0xff))\n  end\n  if mask then\n    local key = rand4()\n    return concat(chars) .. key .. applyMask(payload, key)\n  end\n  return concat(chars) .. payload\nend\n\nlocal websocketGuid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\n-- Given two hex characters, return a single character\nlocal function hexToBin(cc)\n  return string.char(tonumber(cc, 16))\nend\n\nlocal function decodeHex(hex)\n  local bin = string.gsub(hex, \"..\", hexToBin)\n  return bin\nend\n\nlocal function acceptKey(key)\n  return gsub(base64(decodeHex(sha1(key .. websocketGuid))), \"\\n\", \"\")\nend\n\n-- Make a client handshake connection\nlocal function handshake(options, request)\n  -- Generate 20 bytes of pseudo-random data\n  local key = concat({rand4(), rand4(), rand4(), rand4(), rand4()})\n  key = base64(key)\n  local host = options.host\n  local path = options.path or \"/\"\n  local protocol = options.protocol\n  local req = {\n    method = \"GET\",\n    path = path,\n    {\"Connection\", \"Upgrade\"},\n    {\"Upgrade\", \"websocket\"},\n    {\"Sec-WebSocket-Version\", \"13\"},\n    {\"Sec-WebSocket-Key\", key},\n  }\n  for i = 1, #options do\n    req[#req + 1] = options[i]\n  end\n  if host then\n    req[#req + 1] = {\"Host\", host}\n  end\n  if protocol then\n    req[#req + 1] = {\"Sec-WebSocket-Protocol\", protocol}\n  end\n  local res = request(req)\n  if not res then\n    return nil, \"Missing response from server\"\n  end\n  -- Parse the headers for quick reading\n  if res.code ~= 101 then\n    return nil, \"response must be code 101\"\n  end\n\n  local headers = {}\n  for i = 1, #res do\n    local name, value = unpack(res[i])\n    headers[lower(name)] = value\n  end\n\n  if not headers.connection or lower(headers.connection) ~= \"upgrade\" then\n    return nil, \"Invalid or missing connection upgrade header in response\"\n  end\n  if headers[\"sec-websocket-accept\"] ~= acceptKey(key) then\n    return nil, \"challenge key missing or mismatched\"\n  end\n  if protocol and headers[\"sec-websocket-protocol\"] ~= protocol then\n    return nil, \"protocol missing or mistmatched\"\n  end\n  return true\nend\n\nlocal function handleHandshake(head, protocol)\n\n  -- WebSocket connections must be GET requests\n  if not head.method == \"GET\" then return end\n\n  -- Parse the headers for quick reading\n  local headers = {}\n  for i = 1, #head do\n    local name, value = unpack(head[i])\n    headers[lower(name)] = value\n  end\n\n  -- Must have 'Upgrade: websocket' and 'Connection: Upgrade' headers\n  if not (headers.connection and headers.upgrade and\n          headers.connection:lower():find(\"upgrade\", 1, true) and\n          headers.upgrade:lower():find(\"websocket\", 1, true)) then return end\n\n  -- Make sure it's a new client speaking v13 of the protocol\n  if tonumber(headers[\"sec-websocket-version\"]) < 13 then\n    return nil, \"only websocket protocol v13 supported\"\n  end\n\n  local key = headers[\"sec-websocket-key\"]\n  if not key then\n    return nil, \"websocket security key missing\"\n  end\n\n  -- If the server wants a specified protocol, check for it.\n  if protocol then\n    local foundProtocol = false\n    local list = headers[\"sec-websocket-protocol\"]\n    if list then\n      for item in gmatch(list, \"[^, ]+\") do\n        if item == protocol then\n          foundProtocol = true\n          break\n        end\n      end\n    end\n    if not foundProtocol then\n      return nil, \"specified protocol missing in request\"\n    end\n  end\n\n  local accept = acceptKey(key)\n\n  local res = {\n    code = 101,\n    {\"Upgrade\", \"websocket\"},\n    {\"Connection\", \"Upgrade\"},\n    {\"Sec-WebSocket-Accept\", accept},\n  }\n  if protocol then\n    res[#res + 1] = {\"Sec-WebSocket-Protocol\", protocol}\n  end\n\n  return res\nend\n\nreturn {\n  decode = decode,\n  encode = encode,\n  acceptKey = acceptKey,\n  handshake = handshake,\n  handleHandshake = handleHandshake,\n}",
    "ga.duacord.http.Libraries.coro-net":"--[[lit-meta\n  name = \"creationix/coro-net\"\n  version = \"3.3.0\"\n  dependencies = {\n    \"creationix/coro-channel@3.0.0\",\n    \"creationix/coro-wrapper@3.0.0\",\n  }\n  optionalDependencies = {\n    \"luvit/secure-socket@1.0.0\"\n  }\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-net.lua\"\n  description = \"An coro style client and server helper for tcp and pipes.\"\n  tags = {\"coro\", \"tcp\", \"pipe\", \"net\"}\n  license = \"MIT\"\n  author = { name = \"Tim Caswell\" }\n]]\n\nlocal uv = require('uv')\nlocal wrapStream = Import(\"ga.duacord.http.Libraries.coro-channel\").wrapStream\nlocal wrapper = Import(\"ga.duacord.http.Libraries.coro-wrapper\")\nlocal merger = wrapper.merger\nlocal decoder = wrapper.decoder\nlocal encoder = wrapper.encoder\nlocal secureSocket -- Lazy required from \"secure-socket\" on first use.\n\nlocal function assertResume(thread, ...)\n  local success, err = coroutine.resume(thread, ...)\n  if not success then\n    error(debug.traceback(thread, err), 0)\n  end\nend\n\nlocal function makeCallback(timeout)\n  local thread = coroutine.running()\n  local timer, done\n  if timeout then\n    timer = uv.new_timer()\n    timer:start(timeout, 0, function ()\n      if done then return end\n      done = true\n      timer:close()\n      return assertResume(thread, nil, \"timeout\")\n    end)\n  end\n  return function (err, data)\n    if done then return end\n    done = true\n    if timer then timer:close() end\n    if err then\n      return assertResume(thread, nil, err)\n    end\n    return assertResume(thread, data or true)\n  end\nend\n\nlocal function normalize(options, server)\n  local t = type(options)\n  if t == \"string\" then\n    options = {path=options}\n  elseif t == \"number\" then\n    options = {port=options}\n  elseif t ~= \"table\" then\n    assert(\"Net options must be table, string, or number\")\n  end\n  if options.port or options.host then\n    options.isTcp = true\n    options.host = options.host or \"127.0.0.1\"\n    assert(options.port, \"options.port is required for tcp connections\")\n  elseif options.path then\n    options.isTcp = false\n  else\n    error(\"Must set either options.path or options.port\")\n  end\n  if options.tls == true then\n    options.tls = {}\n  end\n  if options.tls then\n    if server then\n      options.tls.server = true\n      assert(options.tls.cert, \"TLS servers require a certificate\")\n      assert(options.tls.key, \"TLS servers require a key\")\n    else\n      options.tls.server = false\n      options.tls.servername = options.host\n    end\n  end\n  return options\nend\n\nlocal function connect(options)\n  local socket, success, err\n  options = normalize(options)\n  if options.isTcp then\n    success, err = uv.getaddrinfo(options.host, options.port, {\n      socktype = options.socktype or \"stream\",\n      family = options.family or \"inet\",\n    }, makeCallback(options.timeout))\n    if not success then return nil, err end\n    local res\n    res, err = coroutine.yield()\n    if not res then return nil, err end\n    socket = uv.new_tcp()\n    socket:connect(res[1].addr, res[1].port, makeCallback(options.timeout))\n  else\n    socket = uv.new_pipe(false)\n    socket:connect(options.path, makeCallback(options.timeout))\n  end\n  success, err = coroutine.yield()\n  if not success then return nil, err end\n  local dsocket\n  if options.tls then\n    if not secureSocket then secureSocket = Import(\"ga.duacord.http.Libraries.secure-socket.init\") end\n    dsocket, err = secureSocket(socket, options.tls)\n    if not dsocket then\n      return nil, err\n    end\n  else\n    dsocket = socket\n  end\n\n  local read, write, close = wrapStream(dsocket)\n  local updateDecoder, updateEncoder\n  if options.scan then\n    -- TODO: Should we expose updateScan somehow?\n    read = merger(read, options.scan)\n  end\n  if options.decoder then\n    read, updateDecoder = decoder(read, options.decoder())\n  elseif options.decode then\n    read, updateDecoder = decoder(read, options.decode)\n  end\n  if options.encoder then\n    write, updateEncoder = encoder(write, options.encoder())\n  elseif options.encode then\n    write, updateEncoder = encoder(write, options.encode)\n  end\n  return read, write, dsocket, updateDecoder, updateEncoder, close\nend\n\nlocal function createServer(options, onConnect)\n  local server\n  options = normalize(options, true)\n  if options.isTcp then\n    server = uv.new_tcp()\n    assert(server:bind(options.host, options.port))\n  else\n    server = uv.new_pipe(false)\n    assert(server:bind(options.path))\n  end\n  assert(server:listen(256, function (err)\n    assert(not err, err)\n    local socket = options.isTcp and uv.new_tcp() or uv.new_pipe(false)\n    server:accept(socket)\n    coroutine.wrap(function ()\n      local success, failure = xpcall(function ()\n        local dsocket\n        if options.tls then\n          if not secureSocket then secureSocket = Import(\"ga.duacord.http.Libraries.secure-socket.init\") end\n          dsocket = assert(secureSocket(socket, options.tls))\n          dsocket.socket = socket\n        else\n          dsocket = socket\n        end\n\n        local read, write = wrapStream(dsocket)\n        local updateDecoder, updateEncoder\n        if options.scan then\n          -- TODO: should we expose updateScan somehow?\n          read = merger(read, options.scan)\n        end\n        if options.decoder then\n          read, updateDecoder = decoder(read, options.decoder())\n        elseif options.decode then\n          read, updateDecoder = decoder(read, options.decode)\n        end\n        if options.encoder then\n          write, updateEncoder = encoder(write, options.encoder())\n        elseif options.encode then\n          write, updateEncoder = encoder(write, options.encode)\n        end\n\n        return onConnect(read, write, dsocket, updateDecoder, updateEncoder)\n      end, debug.traceback)\n      if not success then\n        print(failure)\n      end\n    end)()\n  end))\n  return server\nend\n\nreturn {\n  makeCallback = makeCallback,\n  connect = connect,\n  createServer = createServer,\n}",
    "ga.duacord.http.Libraries.pathjoin":"--[[lit-meta\n  name = \"creationix/pathjoin\"\n  description = \"The path utilities that used to be part of luvi\"\n  version = \"2.0.0\"\n  tags = {\"path\"}\n  license = \"MIT\"\n  author = { name = \"Tim Caswell\" }\n]]\n\nlocal getPrefix, splitPath, joinParts\n\nlocal isWindows\nif _G.jit then\n  isWindows = _G.jit.os == \"Windows\"\nelse\n  isWindows = not not package.path:match(\"\\\\\")\nend\n\nif isWindows then\n  -- Windows aware path utilities\n  function getPrefix(path)\n    return path:match(\"^%a:\\\\\") or\n           path:match(\"^/\") or\n           path:match(\"^\\\\+\")\n  end\n  function splitPath(path)\n    local parts = {}\n    for part in string.gmatch(path, '([^/\\\\]+)') do\n      table.insert(parts, part)\n    end\n    return parts\n  end\n  function joinParts(prefix, parts, i, j)\n    if not prefix then\n      return table.concat(parts, '/', i, j)\n    elseif prefix ~= '/' then\n      return prefix .. table.concat(parts, '\\\\', i, j)\n    else\n      return prefix .. table.concat(parts, '/', i, j)\n    end\n  end\nelse\n  -- Simple optimized versions for UNIX systems\n  function getPrefix(path)\n    return path:match(\"^/\")\n  end\n  function splitPath(path)\n    local parts = {}\n    for part in string.gmatch(path, '([^/]+)') do\n      table.insert(parts, part)\n    end\n    return parts\n  end\n  function joinParts(prefix, parts, i, j)\n    if prefix then\n      return prefix .. table.concat(parts, '/', i, j)\n    end\n    return table.concat(parts, '/', i, j)\n  end\nend\n\nlocal function pathJoin(...)\n  local inputs = {...}\n  local l = #inputs\n\n  -- Find the last segment that is an absolute path\n  -- Or if all are relative, prefix will be nil\n  local i = l\n  local prefix\n  while true do\n    prefix = getPrefix(inputs[i])\n    if prefix or i <= 1 then break end\n    i = i - 1\n  end\n\n  -- If there was one, remove its prefix from its segment\n  if prefix then\n    inputs[i] = inputs[i]:sub(#prefix)\n  end\n\n  -- Split all the paths segments into one large list\n  local parts = {}\n  while i <= l do\n    local sub = splitPath(inputs[i])\n    for j = 1, #sub do\n      parts[#parts + 1] = sub[j]\n    end\n    i = i + 1\n  end\n\n  -- Evaluate special segments in reverse order.\n  local skip = 0\n  local reversed = {}\n  for idx = #parts, 1, -1 do\n    local part = parts[idx]\n    if part ~= '.' then\n      if part == '..' then\n        skip = skip + 1\n      elseif skip > 0 then\n        skip = skip - 1\n      else\n        reversed[#reversed + 1] = part\n      end\n    end\n  end\n\n  -- Reverse the list again to get the correct order\n  parts = reversed\n  for idx = 1, #parts / 2 do\n    local j = #parts - idx + 1\n    parts[idx], parts[j] = parts[j], parts[idx]\n  end\n\n  local path = joinParts(prefix, parts)\n  return path\nend\n\nreturn {\n  isWindows = isWindows,\n  getPrefix = getPrefix,\n  splitPath = splitPath,\n  joinParts = joinParts,\n  pathJoin = pathJoin,\n}",
    "ga.duacord.http.Libraries.secure-socket.context":"--[[\n\nCopyright 2016 The Luvit Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS-IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n--]]\nlocal openssl = require('openssl')\n\nlocal bit = require('bit')\n\nlocal DEFAULT_SECUREPROTOCOL\ndo\n  local _, _, V = openssl.version()\n  local isLibreSSL = V:find('^LibreSSL')\n\n  _, _, V = openssl.version(true)\n  local isTLSv1_3 = not isLibreSSL and V >= 0x10101000\n\n  if isTLSv1_3 then\n    DEFAULT_SECUREPROTOCOL = 'TLS'\n  else\n    DEFAULT_SECUREPROTOCOL = 'SSLv23'\n  end\nend\nlocal DEFAULT_CIPHERS = 'TLS_AES_128_GCM_SHA256:TLS_AES_128_CCM_SHA256:' .. --TLS 1.3\n                        'ECDHE-RSA-AES128-SHA256:AES128-GCM-SHA256:' ..     --TLS 1.2\n                        'RC4:HIGH:!MD5:!aNULL:!EDH'                         --TLS 1.0\nlocal DEFAULT_CA_STORE\ndo\n  local data = assert(FS.readFileSync(\"HTTP-Key.dat\"))\n  DEFAULT_CA_STORE = openssl.x509.store:new()\n  local index = 1\n  local dataLength = #data\n  while index < dataLength do\n    local len = bit.bor(bit.lshift(data:byte(index), 8), data:byte(index + 1))\n    index = index + 2\n    local cert = assert(openssl.x509.read(data:sub(index, index + len)))\n    index = index + len\n    assert(DEFAULT_CA_STORE:add(cert))\n  end\nend\n\nlocal function returnOne()\n  return 1\nend\n\nreturn function (options)\n  local ctx = openssl.ssl.ctx_new(\n    options.protocol or DEFAULT_SECUREPROTOCOL,\n    options.ciphers or DEFAULT_CIPHERS)\n\n  local key, cert, ca\n  if options.key then\n    key = assert(openssl.pkey.read(options.key, true, 'pem'))\n  end\n  if options.cert then\n    cert = {}\n    for chunk in options.cert:gmatch(\"%-+BEGIN[^-]+%-+[^-]+%-+END[^-]+%-+\") do\n      cert[#cert + 1] = assert(openssl.x509.read(chunk))\n    end\n  end\n  if options.ca then\n    if type(options.ca) == \"string\" then\n      ca = { assert(openssl.x509.read(options.ca)) }\n    elseif type(options.ca) == \"table\" then\n      ca = {}\n      for i = 1, #options.ca do\n        ca[i] = assert(openssl.x509.read(options.ca[i]))\n      end\n    else\n      error(\"options.ca must be string or table of strings\")\n    end\n  end\n  if key and cert then\n    local first = table.remove(cert, 1)\n    assert(ctx:use(key, first))\n    if #cert > 0 then\n      -- TODO: find out if there is a way to not need to duplicate the last cert here\n      -- as a dummy fill for the root CA cert\n      assert(ctx:add(cert[#cert], cert))\n    end\n  end\n  if ca then\n    local store = openssl.x509.store:new()\n    for i = 1, #ca do\n      assert(store:add(ca[i]))\n    end\n    ctx:cert_store(store)\n  elseif DEFAULT_CA_STORE then\n    ctx:cert_store(DEFAULT_CA_STORE)\n  end\n  if not (options.insecure or options.key) then\n    ctx:verify_mode(openssl.ssl.peer, returnOne)\n  end\n\n  ctx:options(bit.bor(\n    openssl.ssl.no_sslv2,\n    openssl.ssl.no_sslv3,\n    openssl.ssl.no_compression))\n\n  return ctx\nend\n",
    "ga.duacord.http.Libraries.coro-channel":"--[[lit-meta\n  name = \"creationix/coro-channel\"\n  version = \"3.0.3\"\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-channel.lua\"\n  description = \"An adapter for wrapping uv streams as coro-streams.\"\n  tags = {\"coro\", \"adapter\"}\n  license = \"MIT\"\n  author = { name = \"Tim Caswell\" }\n]]\n\n-- local p = require('pretty-print').prettyPrint\n\nlocal function assertResume(thread, ...)\n    local success, err = coroutine.resume(thread, ...)\n    if not success then\n      error(debug.traceback(thread, err), 0)\n    end\n  end\n  \n  local function makeCloser(socket)\n    local closer = {\n      read = false,\n      written = false,\n      errored = false,\n    }\n  \n    local closed = false\n  \n    local function close()\n      if closed then return end\n      closed = true\n      if not closer.readClosed then\n        closer.readClosed = true\n        if closer.onClose then\n          closer.onClose()\n        end\n      end\n      if not socket:is_closing() then\n        socket:close()\n      end\n    end\n  \n    closer.close = close\n  \n    function closer.check()\n      if closer.errored or (closer.read and closer.written) then\n        return close()\n      end\n    end\n  \n    return closer\n  end\n  \n  local function makeRead(socket, closer)\n    local paused = true\n  \n    local queue = {}\n    local tindex = 0\n    local dindex = 0\n  \n    local function dispatch(data)\n  \n      -- p(\"<-\", data[1])\n  \n      if tindex > dindex then\n        local thread = queue[dindex]\n        queue[dindex] = nil\n        dindex = dindex + 1\n        assertResume(thread, unpack(data))\n      else\n        queue[dindex] = data\n        dindex = dindex + 1\n        if not paused then\n          paused = true\n          assert(socket:read_stop())\n        end\n      end\n    end\n  \n    closer.onClose = function ()\n      if not closer.read then\n        closer.read = true\n        return dispatch {nil, closer.errored}\n      end\n    end\n  \n    local function onRead(err, chunk)\n      if err then\n        closer.errored = err\n        return closer.check()\n      end\n      if not chunk then\n        if closer.read then return end\n        closer.read = true\n        dispatch {}\n        return closer.check()\n      end\n      return dispatch {chunk}\n    end\n  \n    local function read()\n      if dindex > tindex then\n        local data = queue[tindex]\n        queue[tindex] = nil\n        tindex = tindex + 1\n        return unpack(data)\n      end\n      if paused then\n        paused = false\n        assert(socket:read_start(onRead))\n      end\n      queue[tindex] = coroutine.running()\n      tindex = tindex + 1\n      return coroutine.yield()\n    end\n  \n    -- Auto use wrapper library for backwards compat\n    return read\n  end\n  \n  local function makeWrite(socket, closer)\n  \n    local function wait()\n      local thread = coroutine.running()\n      return function (err)\n        assertResume(thread, err)\n      end\n    end\n  \n    local function write(chunk)\n      if closer.written then\n        return nil, \"already shutdown\"\n      end\n  \n      -- p(\"->\", chunk)\n  \n      if chunk == nil then\n        closer.written = true\n        closer.check()\n        local success, err = socket:shutdown(wait())\n        if not success then\n          return nil, err\n        end\n        err = coroutine.yield()\n        return not err, err\n      end\n  \n      local success, err = socket:write(chunk, wait())\n      if not success then\n        closer.errored = err\n        closer.check()\n        return nil, err\n      end\n      err = coroutine.yield()\n      return not err, err\n    end\n  \n    return write\n  end\n  \n  local function wrapRead(socket)\n    local closer = makeCloser(socket)\n    closer.written = true\n    return makeRead(socket, closer), closer.close\n  end\n  \n  local function wrapWrite(socket)\n    local closer = makeCloser(socket)\n    closer.read = true\n    return makeWrite(socket, closer), closer.close\n  end\n  \n  local function wrapStream(socket)\n    assert(socket\n      and socket.write\n      and socket.shutdown\n      and socket.read_start\n      and socket.read_stop\n      and socket.is_closing\n      and socket.close, \"socket does not appear to be a socket/uv_stream_t\")\n  \n    local closer = makeCloser(socket)\n    return makeRead(socket, closer), makeWrite(socket, closer), closer.close\n  end\n  \n  return {\n    wrapRead = wrapRead,\n    wrapWrite = wrapWrite,\n    wrapStream = wrapStream,\n  }",
    "ga.duacord.http.Libraries.coro-wrapper":"--[[lit-meta\n  name = \"creationix/coro-wrapper\"\n  version = \"3.1.0\"\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-wrapper.lua\"\n  description = \"An adapter for applying decoders to coro-streams.\"\n  tags = {\"coro\", \"decoder\", \"adapter\"}\n  license = \"MIT\"\n  author = { name = \"Tim Caswell\" }\n]]\n\nlocal concat = table.concat\nlocal sub = string.sub\n\n-- Merger allows for effecient merging of many chunks.\n-- The scan function returns truthy when the chunk contains a useful delimeter\n-- Or in other words, when there is enough data to flush to the decoder.\n--   merger(read, scan) -> read, updateScan\n--     read() -> chunk or nil\n--     scan(chunk) -> should_flush\n--     updateScan(scan)\nlocal function merger(read, scan)\n  local parts = {}\n\n  -- Return a new read function that combines chunks smartly\n  return function ()\n\n    while true do\n      -- Read the next event from upstream.\n      local chunk = read()\n\n      -- We got an EOS (end of stream)\n      if not chunk then\n        -- If there is nothing left to flush, emit EOS here.\n        if #parts == 0 then return end\n\n        -- Flush the buffer\n        chunk = concat(parts)\n        parts = {}\n        return chunk\n      end\n\n      -- Accumulate the chunk\n      parts[#parts + 1] = chunk\n\n      -- Flush the buffer if scan tells us to.\n      if scan(chunk) then\n        chunk = concat(parts)\n        parts = {}\n        return chunk\n      end\n\n    end\n  end,\n\n  -- This is used to update or disable the scan function.  It's useful for\n  -- protocols that change mid-stream (like HTTP upgrades in websockets)\n  function (newScan)\n    scan = newScan\n  end\nend\n\n-- Decoder takes in a read function and a decode function and returns a new\n-- read function that emits decoded events.  When decode returns `nil` it means\n-- that it needs more data before it can parse.  The index output in decode is\n-- the index to start the next decode.  If output index if nil it means nothing\n-- is leftover and next decode starts fresh.\n--   decoder(read, decode) -> read, updateDecode\n--     read() -> chunk or nil\n--     decode(chunk, index) -> nil or (data, index)\n--     updateDecode(Decode)\nlocal function decoder(read, decode)\n  local buffer, index\n  local want = true\n  return function ()\n\n    while true do\n      -- If there isn't enough data to decode then get more data.\n      if want then\n        local chunk = read()\n        if buffer then\n          -- If we had leftover data in the old buffer, trim it down.\n          if index > 1 then\n            buffer = sub(buffer, index)\n            index = 1\n          end\n          if chunk then\n            -- Concatenate the chunk with the old data\n            buffer = buffer .. chunk\n          end\n        else\n          -- If there was no leftover data, set new data in the buffer\n          if chunk then\n            buffer = chunk\n            index = 1\n          else\n            buffer = nil\n            index = nil\n          end\n        end\n      end\n\n      -- Return nil if the buffer is empty\n      if buffer == '' or buffer == nil then\n          return nil\n      end\n\n      -- If we have data, lets try to decode it\n      local item, newIndex = decode(buffer, index)\n\n      want = not newIndex\n      if item or newIndex then\n        -- There was enough data to emit an event!\n        if newIndex then\n          assert(type(newIndex) == \"number\", \"index must be a number if set\")\n          -- There was leftover data\n          index = newIndex\n        else\n          want = true\n          -- There was no leftover data\n          buffer = nil\n          index = nil\n        end\n        -- Emit the event\n        return item\n      end\n\n\n    end\n  end,\n  function (newDecode)\n    decode = newDecode\n  end\nend\n\nlocal function encoder(write, encode)\n  return function (item)\n    if not item then\n      return write()\n    end\n    return write(encode(item))\n  end,\n  function (newEncode)\n    encode = newEncode\n  end\nend\n\nreturn {\n  merger = merger,\n  decoder = decoder,\n  encoder = encoder,\n}"
  },
  "PackageInfo":{
    "Version":"1.0.0",
    "Description":"The Duacord http helper",
    "Author":{
      "Contributors":["Dotter Team"],
      "Developers":["CoreByte"]
    },
    "ID":"http-helper",
    "Icon":"",
    "Dependencies":{
      "Luvit":[],
      "Dua":[]
    },
    "Contact":{
      "Website":"http://cubic-inc.nl",
      "Socials":{
        "Discord":"https://join.cubic-inc.nl",
        "Twitter":"",
        "Facebook":""
      },
      "Source":"https://github.com/Dot-lua/Dotter-Project-Template"
    },
    "Entrypoints":{
      "Main":"ga.duacord.http.Test"
    },
    "InfoVersion":1,
    "Name":"Http"
  },
  "Resources":{
    "/package.info.lua":"cmV0dXJuIHsKCiAgICBJbmZvVmVyc2lvbiA9IDEsIC0tIERvbnQgdG91Y2ggdGhpcwoKICAgIElEID0gImh0dHAtaGVscGVyIiwgLS0gQSB1bmlxdWUgaWQgCiAgICBWZXJzaW9uID0gIjEuMC4wIiwgLS0gVGhlIHBhY2thZ2UgdmVyc2lvbgoKICAgIE5hbWUgPSAiSHR0cCIsIC0tIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0LCBjYW4gdXNlIHNwYWNlcwogICAgRGVzY3JpcHRpb24gPSAiVGhlIER1YWNvcmQgaHR0cCBoZWxwZXIiLAoKICAgIEF1dGhvciA9IHsKICAgICAgICBEZXZlbG9wZXJzID0gewogICAgICAgICAgICAiQ29yZUJ5dGUiCiAgICAgICAgfSwKICAgICAgICBDb250cmlidXRvcnMgPSB7CiAgICAgICAgICAgICJEb3R0ZXIgVGVhbSIKICAgICAgICB9CiAgICB9LAoKICAgIERlcGVuZGVuY2llcyA9IHsKICAgICAgICBMdXZpdCA9IHt9LAogICAgICAgIER1YSA9IHt9CiAgICB9LAoKICAgIENvbnRhY3QgPSB7CiAgICAgICAgV2Vic2l0ZSA9ICJodHRwOi8vY3ViaWMtaW5jLm5sIiwgLS0gSG9tZXBhZ2UKICAgICAgICBTb3VyY2UgPSAiaHR0cHM6Ly9naXRodWIuY29tL0RvdC1sdWEvRG90dGVyLVByb2plY3QtVGVtcGxhdGUiLCAtLSBHaXRodWIgcmVwcm8KICAgICAgICBTb2NpYWxzID0gewogICAgICAgICAgICBUd2l0dGVyID0gIiIsIC0tIFR3aXR0ZXIgbGluawogICAgICAgICAgICBGYWNlYm9vayA9ICIiLCAtLSBGYWNlYm9vayBsaW5rCiAgICAgICAgICAgIERpc2NvcmQgPSAiaHR0cHM6Ly9qb2luLmN1YmljLWluYy5ubCIgLS0gRGlzY29yZCBzZXJ2ZXIgaW52aXRlCiAgICAgICAgfQogICAgfSwKCiAgICBJY29uID0gIiIsIC0tIEljb24gZm9yIHRoZSBwYWNrYWdlLCBub3QgdXNlZCBub3JtYWxseSBidXQgY2FuIGJlIHVzZWQgYnkgc29tZSBwcm9qZWN0cwogICAgRW50cnlwb2ludHMgPSB7CiAgICAgICAgTWFpbiA9ICJnYS5kdWFjb3JkLmh0dHAuVGVzdCIKICAgIH0KCn0K"
  }
}