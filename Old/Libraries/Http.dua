{"Code":{"ga.duacord.http.Libraries.coro-wrapper":"--[[lit-meta\r\n  name = \"creationix/coro-wrapper\"\r\n  version = \"3.1.0\"\r\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-wrapper.lua\"\r\n  description = \"An adapter for applying decoders to coro-streams.\"\r\n  tags = {\"coro\", \"decoder\", \"adapter\"}\r\n  license = \"MIT\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\nlocal concat = table.concat\r\nlocal sub = string.sub\r\n\r\n-- Merger allows for effecient merging of many chunks.\r\n-- The scan function returns truthy when the chunk contains a useful delimeter\r\n-- Or in other words, when there is enough data to flush to the decoder.\r\n--   merger(read, scan) -> read, updateScan\r\n--     read() -> chunk or nil\r\n--     scan(chunk) -> should_flush\r\n--     updateScan(scan)\r\nlocal function merger(read, scan)\r\n  local parts = {}\r\n\r\n  -- Return a new read function that combines chunks smartly\r\n  return function ()\r\n\r\n    while true do\r\n      -- Read the next event from upstream.\r\n      local chunk = read()\r\n\r\n      -- We got an EOS (end of stream)\r\n      if not chunk then\r\n        -- If there is nothing left to flush, emit EOS here.\r\n        if #parts == 0 then return end\r\n\r\n        -- Flush the buffer\r\n        chunk = concat(parts)\r\n        parts = {}\r\n        return chunk\r\n      end\r\n\r\n      -- Accumulate the chunk\r\n      parts[#parts + 1] = chunk\r\n\r\n      -- Flush the buffer if scan tells us to.\r\n      if scan(chunk) then\r\n        chunk = concat(parts)\r\n        parts = {}\r\n        return chunk\r\n      end\r\n\r\n    end\r\n  end,\r\n\r\n  -- This is used to update or disable the scan function.  It's useful for\r\n  -- protocols that change mid-stream (like HTTP upgrades in websockets)\r\n  function (newScan)\r\n    scan = newScan\r\n  end\r\nend\r\n\r\n-- Decoder takes in a read function and a decode function and returns a new\r\n-- read function that emits decoded events.  When decode returns `nil` it means\r\n-- that it needs more data before it can parse.  The index output in decode is\r\n-- the index to start the next decode.  If output index if nil it means nothing\r\n-- is leftover and next decode starts fresh.\r\n--   decoder(read, decode) -> read, updateDecode\r\n--     read() -> chunk or nil\r\n--     decode(chunk, index) -> nil or (data, index)\r\n--     updateDecode(Decode)\r\nlocal function decoder(read, decode)\r\n  local buffer, index\r\n  local want = true\r\n  return function ()\r\n\r\n    while true do\r\n      -- If there isn't enough data to decode then get more data.\r\n      if want then\r\n        local chunk = read()\r\n        if buffer then\r\n          -- If we had leftover data in the old buffer, trim it down.\r\n          if index > 1 then\r\n            buffer = sub(buffer, index)\r\n            index = 1\r\n          end\r\n          if chunk then\r\n            -- Concatenate the chunk with the old data\r\n            buffer = buffer .. chunk\r\n          end\r\n        else\r\n          -- If there was no leftover data, set new data in the buffer\r\n          if chunk then\r\n            buffer = chunk\r\n            index = 1\r\n          else\r\n            buffer = nil\r\n            index = nil\r\n          end\r\n        end\r\n      end\r\n\r\n      -- Return nil if the buffer is empty\r\n      if buffer == '' or buffer == nil then\r\n          return nil\r\n      end\r\n\r\n      -- If we have data, lets try to decode it\r\n      local item, newIndex = decode(buffer, index)\r\n\r\n      want = not newIndex\r\n      if item or newIndex then\r\n        -- There was enough data to emit an event!\r\n        if newIndex then\r\n          assert(type(newIndex) == \"number\", \"index must be a number if set\")\r\n          -- There was leftover data\r\n          index = newIndex\r\n        else\r\n          want = true\r\n          -- There was no leftover data\r\n          buffer = nil\r\n          index = nil\r\n        end\r\n        -- Emit the event\r\n        return item\r\n      end\r\n\r\n\r\n    end\r\n  end,\r\n  function (newDecode)\r\n    decode = newDecode\r\n  end\r\nend\r\n\r\nlocal function encoder(write, encode)\r\n  return function (item)\r\n    if not item then\r\n      return write()\r\n    end\r\n    return write(encode(item))\r\n  end,\r\n  function (newEncode)\r\n    encode = newEncode\r\n  end\r\nend\r\n\r\nreturn {\r\n  merger = merger,\r\n  decoder = decoder,\r\n  encoder = encoder,\r\n}","ga.duacord.http.Libraries.websocket-codec":"--[[lit-meta\r\n  name = \"creationix/websocket-codec\"\r\n  description = \"A codec implementing websocket framing and helpers for handshakeing\"\r\n  version = \"3.0.2\"\r\n  dependencies = {\r\n    \"creationix/base64@2.0.0\",\r\n    \"creationix/sha1@1.0.0\",\r\n  }\r\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/websocket-codec.lua\"\r\n  tags = {\"http\", \"websocket\", \"codec\"}\r\n  license = \"MIT\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\nlocal base64 = Import(\"ga.duacord.http.Libraries.base64\").encode\r\nlocal sha1 = Import(\"ga.duacord.http.Libraries.sha1\")\r\nlocal bit = require('bit')\r\n\r\nlocal band = bit.band\r\nlocal bor = bit.bor\r\nlocal bxor = bit.bxor\r\nlocal rshift = bit.rshift\r\nlocal lshift = bit.lshift\r\nlocal char = string.char\r\nlocal byte = string.byte\r\nlocal sub = string.sub\r\nlocal gmatch = string.gmatch\r\nlocal lower = string.lower\r\nlocal gsub = string.gsub\r\nlocal concat = table.concat\r\nlocal floor = math.floor\r\nlocal random = math.random\r\n\r\nlocal function rand4()\r\n  -- Generate 32 bits of pseudo random data\r\n  local num = floor(random() * 0x100000000)\r\n  -- Return as a 4-byte string\r\n  return char(\r\n    rshift(num, 24),\r\n    band(rshift(num, 16), 0xff),\r\n    band(rshift(num, 8), 0xff),\r\n    band(num, 0xff)\r\n  )\r\nend\r\n\r\nlocal function applyMask(data, mask)\r\n  local bytes = {\r\n    [0] = byte(mask, 1),\r\n    [1] = byte(mask, 2),\r\n    [2] = byte(mask, 3),\r\n    [3] = byte(mask, 4)\r\n  }\r\n  local out = {}\r\n  for i = 1, #data do\r\n    out[i] = char(\r\n      bxor(byte(data, i), bytes[(i - 1) % 4])\r\n    )\r\n  end\r\n  return concat(out)\r\nend\r\n\r\nlocal function decode(chunk, index)\r\n  local start = index - 1\r\n  local length = #chunk - start\r\n  if length < 2 then return end\r\n  local second = byte(chunk, start + 2)\r\n  local len = band(second, 0x7f)\r\n  local offset\r\n  if len == 126 then\r\n    if length < 4 then return end\r\n    len = bor(\r\n      lshift(byte(chunk, start + 3), 8),\r\n      byte(chunk, start + 4))\r\n    offset = 4\r\n  elseif len == 127 then\r\n    if length < 10 then return end\r\n    len = bor(\r\n      lshift(byte(chunk, start + 3), 24),\r\n      lshift(byte(chunk, start + 4), 16),\r\n      lshift(byte(chunk, start + 5), 8),\r\n      byte(chunk, start + 6)\r\n    ) * 0x100000000 + bor(\r\n      lshift(byte(chunk, start + 7), 24),\r\n      lshift(byte(chunk, start + 8), 16),\r\n      lshift(byte(chunk, start + 9), 8),\r\n      byte(chunk, start + 10)\r\n    )\r\n    offset = 10\r\n  else\r\n    offset = 2\r\n  end\r\n  local mask = band(second, 0x80) > 0\r\n  if mask then\r\n    offset = offset + 4\r\n  end\r\n  offset = offset + start\r\n  if #chunk < offset + len then return end\r\n\r\n  local first = byte(chunk, start + 1)\r\n  local payload = sub(chunk, offset + 1, offset + len)\r\n  assert(#payload == len, \"Length mismatch\")\r\n  if mask then\r\n    payload = applyMask(payload, sub(chunk, offset - 3, offset))\r\n  end\r\n  return {\r\n    fin = band(first, 0x80) > 0,\r\n    rsv1 = band(first, 0x40) > 0,\r\n    rsv2 = band(first, 0x20) > 0,\r\n    rsv3 = band(first, 0x10) > 0,\r\n    opcode = band(first, 0xf),\r\n    mask = mask,\r\n    len = len,\r\n    payload = payload\r\n  }, offset + len + 1\r\nend\r\n\r\nlocal function encode(item)\r\n  if type(item) == \"string\" then\r\n    item = {\r\n      opcode = 2,\r\n      payload = item\r\n    }\r\n  end\r\n  local payload = item.payload\r\n  assert(type(payload) == \"string\", \"payload must be string\")\r\n  local len = #payload\r\n  local fin = item.fin\r\n  if fin == nil then fin = true end\r\n  local rsv1 = item.rsv1\r\n  local rsv2 = item.rsv2\r\n  local rsv3 = item.rsv3\r\n  local opcode = item.opcode or 2\r\n  local mask = item.mask\r\n  local chars = {\r\n    char(bor(\r\n      fin and 0x80 or 0,\r\n      rsv1 and 0x40 or 0,\r\n      rsv2 and 0x20 or 0,\r\n      rsv3 and 0x10 or 0,\r\n      opcode\r\n    )),\r\n    char(bor(\r\n      mask and 0x80 or 0,\r\n      len < 126 and len or (len < 0x10000) and 126 or 127\r\n    ))\r\n  }\r\n  if len >= 0x10000 then\r\n    local high = len / 0x100000000\r\n    chars[3] = char(band(rshift(high, 24), 0xff))\r\n    chars[4] = char(band(rshift(high, 16), 0xff))\r\n    chars[5] = char(band(rshift(high, 8), 0xff))\r\n    chars[6] = char(band(high, 0xff))\r\n    chars[7] = char(band(rshift(len, 24), 0xff))\r\n    chars[8] = char(band(rshift(len, 16), 0xff))\r\n    chars[9] = char(band(rshift(len, 8), 0xff))\r\n    chars[10] = char(band(len, 0xff))\r\n  elseif len >= 126 then\r\n    chars[3] = char(band(rshift(len, 8), 0xff))\r\n    chars[4] = char(band(len, 0xff))\r\n  end\r\n  if mask then\r\n    local key = rand4()\r\n    return concat(chars) .. key .. applyMask(payload, key)\r\n  end\r\n  return concat(chars) .. payload\r\nend\r\n\r\nlocal websocketGuid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\r\n\r\n-- Given two hex characters, return a single character\r\nlocal function hexToBin(cc)\r\n  return string.char(tonumber(cc, 16))\r\nend\r\n\r\nlocal function decodeHex(hex)\r\n  local bin = string.gsub(hex, \"..\", hexToBin)\r\n  return bin\r\nend\r\n\r\nlocal function acceptKey(key)\r\n  return gsub(base64(decodeHex(sha1(key .. websocketGuid))), \"\\n\", \"\")\r\nend\r\n\r\n-- Make a client handshake connection\r\nlocal function handshake(options, request)\r\n  -- Generate 20 bytes of pseudo-random data\r\n  local key = concat({rand4(), rand4(), rand4(), rand4(), rand4()})\r\n  key = base64(key)\r\n  local host = options.host\r\n  local path = options.path or \"/\"\r\n  local protocol = options.protocol\r\n  local req = {\r\n    method = \"GET\",\r\n    path = path,\r\n    {\"Connection\", \"Upgrade\"},\r\n    {\"Upgrade\", \"websocket\"},\r\n    {\"Sec-WebSocket-Version\", \"13\"},\r\n    {\"Sec-WebSocket-Key\", key},\r\n  }\r\n  for i = 1, #options do\r\n    req[#req + 1] = options[i]\r\n  end\r\n  if host then\r\n    req[#req + 1] = {\"Host\", host}\r\n  end\r\n  if protocol then\r\n    req[#req + 1] = {\"Sec-WebSocket-Protocol\", protocol}\r\n  end\r\n  local res = request(req)\r\n  if not res then\r\n    return nil, \"Missing response from server\"\r\n  end\r\n  -- Parse the headers for quick reading\r\n  if res.code ~= 101 then\r\n    return nil, \"response must be code 101\"\r\n  end\r\n\r\n  local headers = {}\r\n  for i = 1, #res do\r\n    local name, value = unpack(res[i])\r\n    headers[lower(name)] = value\r\n  end\r\n\r\n  if not headers.connection or lower(headers.connection) ~= \"upgrade\" then\r\n    return nil, \"Invalid or missing connection upgrade header in response\"\r\n  end\r\n  if headers[\"sec-websocket-accept\"] ~= acceptKey(key) then\r\n    return nil, \"challenge key missing or mismatched\"\r\n  end\r\n  if protocol and headers[\"sec-websocket-protocol\"] ~= protocol then\r\n    return nil, \"protocol missing or mistmatched\"\r\n  end\r\n  return true\r\nend\r\n\r\nlocal function handleHandshake(head, protocol)\r\n\r\n  -- WebSocket connections must be GET requests\r\n  if not head.method == \"GET\" then return end\r\n\r\n  -- Parse the headers for quick reading\r\n  local headers = {}\r\n  for i = 1, #head do\r\n    local name, value = unpack(head[i])\r\n    headers[lower(name)] = value\r\n  end\r\n\r\n  -- Must have 'Upgrade: websocket' and 'Connection: Upgrade' headers\r\n  if not (headers.connection and headers.upgrade and\r\n          headers.connection:lower():find(\"upgrade\", 1, true) and\r\n          headers.upgrade:lower():find(\"websocket\", 1, true)) then return end\r\n\r\n  -- Make sure it's a new client speaking v13 of the protocol\r\n  if tonumber(headers[\"sec-websocket-version\"]) < 13 then\r\n    return nil, \"only websocket protocol v13 supported\"\r\n  end\r\n\r\n  local key = headers[\"sec-websocket-key\"]\r\n  if not key then\r\n    return nil, \"websocket security key missing\"\r\n  end\r\n\r\n  -- If the server wants a specified protocol, check for it.\r\n  if protocol then\r\n    local foundProtocol = false\r\n    local list = headers[\"sec-websocket-protocol\"]\r\n    if list then\r\n      for item in gmatch(list, \"[^, ]+\") do\r\n        if item == protocol then\r\n          foundProtocol = true\r\n          break\r\n        end\r\n      end\r\n    end\r\n    if not foundProtocol then\r\n      return nil, \"specified protocol missing in request\"\r\n    end\r\n  end\r\n\r\n  local accept = acceptKey(key)\r\n\r\n  local res = {\r\n    code = 101,\r\n    {\"Upgrade\", \"websocket\"},\r\n    {\"Connection\", \"Upgrade\"},\r\n    {\"Sec-WebSocket-Accept\", accept},\r\n  }\r\n  if protocol then\r\n    res[#res + 1] = {\"Sec-WebSocket-Protocol\", protocol}\r\n  end\r\n\r\n  return res\r\nend\r\n\r\nreturn {\r\n  decode = decode,\r\n  encode = encode,\r\n  acceptKey = acceptKey,\r\n  handshake = handshake,\r\n  handleHandshake = handleHandshake,\r\n}","ga.duacord.http.Libraries.base64":"--[[lit-meta\r\n  name = \"creationix/base64\"\r\n  description = \"A pure lua implemention of base64 using bitop\"\r\n  tags = {\"crypto\", \"base64\", \"bitop\"}\r\n  version = \"2.0.0\"\r\n  license = \"MIT\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\nlocal bit = require 'bit'\r\nlocal rshift = bit.rshift\r\nlocal lshift = bit.lshift\r\nlocal bor = bit.bor\r\nlocal band = bit.band\r\nlocal char = string.char\r\nlocal byte = string.byte\r\nlocal concat = table.concat\r\nlocal codes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\r\n\r\n-- Loop over input 3 bytes at a time\r\n-- a,b,c are 3 x 8-bit numbers\r\n-- they are encoded into groups of 4 x 6-bit numbers\r\n-- aaaaaa aabbbb bbbbcc cccccc\r\n-- if there is no c, then pad the 4th with =\r\n-- if there is also no b then pad the 3rd with =\r\nlocal function base64Encode(str)\r\n  local parts = {}\r\n  local j = 1\r\n  for i = 1, #str, 3 do\r\n    local a, b, c = byte(str, i, i + 2)\r\n    parts[j] = char(\r\n      -- Higher 6 bits of a\r\n      byte(codes, rshift(a, 2) + 1),\r\n      -- Lower 2 bits of a + high 4 bits of b\r\n      byte(codes, bor(\r\n        lshift(band(a, 3), 4),\r\n        b and rshift(b, 4) or 0\r\n      ) + 1),\r\n      -- Low 4 bits of b + High 2 bits of c\r\n      b and byte(codes, bor(\r\n        lshift(band(b, 15), 2),\r\n        c and rshift(c, 6) or 0\r\n      ) + 1) or 61, -- 61 is '='\r\n      -- Lower 6 bits of c\r\n      c and byte(codes, band(c, 63) + 1) or 61 -- 61 is '='\r\n    )\r\n    j = j + 1\r\n  end\r\n  return concat(parts)\r\nend\r\n\r\n-- Reverse map from character code to 6-bit integer\r\nlocal map = {}\r\nfor i = 1, #codes do\r\n  map[byte(codes, i)] = i - 1\r\nend\r\n\r\n-- loop over input 4 characters at a time\r\n-- The characters are mapped to 4 x 6-bit integers a,b,c,d\r\n-- They need to be reassalbled into 3 x 8-bit bytes\r\n-- aaaaaabb bbbbcccc ccdddddd\r\n-- if d is padding then there is no 3rd byte\r\n-- if c is padding then there is no 2nd byte\r\nlocal function base64Decode(data)\r\n  local bytes = {}\r\n  local j = 1\r\n  for i = 1, #data, 4 do\r\n    local a = map[byte(data, i)]\r\n    local b = map[byte(data, i + 1)]\r\n    local c = map[byte(data, i + 2)]\r\n    local d = map[byte(data, i + 3)]\r\n\r\n    -- higher 6 bits are the first char\r\n    -- lower 2 bits are upper 2 bits of second char\r\n    bytes[j] = char(bor(lshift(a, 2), rshift(b, 4)))\r\n\r\n    -- if the third char is not padding, we have a second byte\r\n    if c < 64 then\r\n      -- high 4 bits come from lower 4 bits in b\r\n      -- low 4 bits come from high 4 bits in c\r\n      bytes[j + 1] = char(bor(lshift(band(b, 0xf), 4), rshift(c, 2)))\r\n\r\n      -- if the fourth char is not padding, we have a third byte\r\n      if d < 64 then\r\n        -- Upper 2 bits come from Lower 2 bits of c\r\n        -- Lower 6 bits come from d\r\n        bytes[j + 2] = char(bor(lshift(band(c, 3), 6), d))\r\n      end\r\n    end\r\n    j = j + 3\r\n  end\r\n  return concat(bytes)\r\nend\r\n\r\nassert(base64Encode(\"\") == \"\")\r\nassert(base64Encode(\"f\") == \"Zg==\")\r\nassert(base64Encode(\"fo\") == \"Zm8=\")\r\nassert(base64Encode(\"foo\") == \"Zm9v\")\r\nassert(base64Encode(\"foob\") == \"Zm9vYg==\")\r\nassert(base64Encode(\"fooba\") == \"Zm9vYmE=\")\r\nassert(base64Encode(\"foobar\") == \"Zm9vYmFy\")\r\n\r\nassert(base64Decode(\"\") == \"\")\r\nassert(base64Decode(\"Zg==\") == \"f\")\r\nassert(base64Decode(\"Zm8=\") == \"fo\")\r\nassert(base64Decode(\"Zm9v\") == \"foo\")\r\nassert(base64Decode(\"Zm9vYg==\") == \"foob\")\r\nassert(base64Decode(\"Zm9vYmE=\") == \"fooba\")\r\nassert(base64Decode(\"Zm9vYmFy\") == \"foobar\")\r\n\r\nreturn {\r\n  encode = base64Encode,\r\n  decode = base64Decode,\r\n}","ga.duacord.http.Test":"local Package = {}\r\n\r\nLoadPackage(\"./Libraries/Logger.dua\")\r\n\r\n\r\n\r\nfunction Package.OnInitialize()\r\n\r\n  local Logger = Import(\"nl.cubic-inc.logger.Main\")\r\n  local Http = Import(\"ga.duacord.http.Main\")\r\n\r\n  Logger:Info(\"Package loaded!\")\r\n\r\n  p(Http[\"coro-http\"].request(\"GET\", \"https://google.nl\"))\r\n\r\nend\r\n\r\nreturn Package\r\n","ga.duacord.http.Libraries.http-codec":"--[[\r\nCopyright 2014-2015 The Luvit Authors. All Rights Reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS-IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n--]]\r\n\r\n--[[lit-meta\r\n  name = \"luvit/http-codec\"\r\n  version = \"3.0.6\"\r\n  homepage = \"https://github.com/luvit/luvit/blob/master/deps/http-codec.lua\"\r\n  description = \"A simple pair of functions for converting between hex and raw strings.\"\r\n  tags = {\"codec\", \"http\"}\r\n  license = \"Apache 2\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\nlocal sub = string.sub\r\nlocal gsub = string.gsub\r\nlocal lower = string.lower\r\nlocal find = string.find\r\nlocal format = string.format\r\nlocal concat = table.concat\r\nlocal match = string.match\r\n\r\nlocal STATUS_CODES = {\r\n  [100] = 'Continue',\r\n  [101] = 'Switching Protocols',\r\n  [102] = 'Processing',                 -- RFC 2518, obsoleted by RFC 4918\r\n  [200] = 'OK',\r\n  [201] = 'Created',\r\n  [202] = 'Accepted',\r\n  [203] = 'Non-Authoritative Information',\r\n  [204] = 'No Content',\r\n  [205] = 'Reset Content',\r\n  [206] = 'Partial Content',\r\n  [207] = 'Multi-Status',               -- RFC 4918\r\n  [300] = 'Multiple Choices',\r\n  [301] = 'Moved Permanently',\r\n  [302] = 'Moved Temporarily',\r\n  [303] = 'See Other',\r\n  [304] = 'Not Modified',\r\n  [305] = 'Use Proxy',\r\n  [307] = 'Temporary Redirect',\r\n  [400] = 'Bad Request',\r\n  [401] = 'Unauthorized',\r\n  [402] = 'Payment Required',\r\n  [403] = 'Forbidden',\r\n  [404] = 'Not Found',\r\n  [405] = 'Method Not Allowed',\r\n  [406] = 'Not Acceptable',\r\n  [407] = 'Proxy Authentication Required',\r\n  [408] = 'Request Time-out',\r\n  [409] = 'Conflict',\r\n  [410] = 'Gone',\r\n  [411] = 'Length Required',\r\n  [412] = 'Precondition Failed',\r\n  [413] = 'Request Entity Too Large',\r\n  [414] = 'Request-URI Too Large',\r\n  [415] = 'Unsupported Media Type',\r\n  [416] = 'Requested Range Not Satisfiable',\r\n  [417] = 'Expectation Failed',\r\n  [418] = \"I'm a teapot\",                       -- RFC 2324\r\n  [422] = 'Unprocessable Entity',               -- RFC 4918\r\n  [423] = 'Locked',                             -- RFC 4918\r\n  [424] = 'Failed Dependency',                  -- RFC 4918\r\n  [425] = 'Unordered Collection',               -- RFC 4918\r\n  [426] = 'Upgrade Required',                   -- RFC 2817\r\n  [428] = 'Precondition Required',              -- RFC 6585\r\n  [429] = 'Too Many Requests',                  -- RFC 6585\r\n  [431] = 'Request Header Fields Too Large',    -- RFC 6585\r\n  [500] = 'Internal Server Error',\r\n  [501] = 'Not Implemented',\r\n  [502] = 'Bad Gateway',\r\n  [503] = 'Service Unavailable',\r\n  [504] = 'Gateway Time-out',\r\n  [505] = 'HTTP Version not supported',\r\n  [506] = 'Variant Also Negotiates',            -- RFC 2295\r\n  [507] = 'Insufficient Storage',               -- RFC 4918\r\n  [509] = 'Bandwidth Limit Exceeded',\r\n  [510] = 'Not Extended',                       -- RFC 2774\r\n  [511] = 'Network Authentication Required'     -- RFC 6585\r\n}\r\n\r\nlocal function encoder()\r\n\r\n  local mode\r\n  local encodeHead, encodeRaw, encodeChunked\r\n\r\n  function encodeHead(item)\r\n    if not item or item == \"\" then\r\n      return item\r\n    elseif not (type(item) == \"table\") then\r\n      error(\"expected a table but got a \" .. type(item) .. \" when encoding data\")\r\n    end\r\n    local head, chunkedEncoding\r\n    local version = item.version or 1.1\r\n    if item.method then\r\n      local path = item.path\r\n      assert(path and #path > 0, \"expected non-empty path\")\r\n      head = { item.method .. ' ' .. item.path .. ' HTTP/' .. version .. '\\r\\n' }\r\n    else\r\n      local reason = item.reason or STATUS_CODES[item.code]\r\n      head = { 'HTTP/' .. version .. ' ' .. item.code .. ' ' .. reason .. '\\r\\n' }\r\n    end\r\n    for i = 1, #item do\r\n      local key, value = unpack(item[i])\r\n      local lowerKey = lower(key)\r\n      if lowerKey == \"transfer-encoding\" then\r\n        chunkedEncoding = lower(value) == \"chunked\"\r\n      end\r\n      value = gsub(tostring(value), \"[\\r\\n]+\", \" \")\r\n      head[#head + 1] = key .. ': ' .. tostring(value) .. '\\r\\n'\r\n    end\r\n    head[#head + 1] = '\\r\\n'\r\n\r\n    mode = chunkedEncoding and encodeChunked or encodeRaw\r\n    return concat(head)\r\n  end\r\n\r\n  function encodeRaw(item)\r\n    if type(item) ~= \"string\" then\r\n      mode = encodeHead\r\n      return encodeHead(item)\r\n    end\r\n    return item\r\n  end\r\n\r\n  function encodeChunked(item)\r\n    if type(item) ~= \"string\" then\r\n      mode = encodeHead\r\n      local extra = encodeHead(item)\r\n      if extra then\r\n        return \"0\\r\\n\\r\\n\" .. extra\r\n      else\r\n        return \"0\\r\\n\\r\\n\"\r\n      end\r\n    end\r\n    if #item == 0 then\r\n      mode = encodeHead\r\n    end\r\n    return format(\"%x\", #item) .. \"\\r\\n\" .. item .. \"\\r\\n\"\r\n  end\r\n\r\n  mode = encodeHead\r\n  return function (item)\r\n    return mode(item)\r\n  end\r\nend\r\n\r\nlocal function decoder()\r\n\r\n  -- This decoder is somewhat stateful with 5 different parsing states.\r\n  local decodeHead, decodeEmpty, decodeRaw, decodeChunked, decodeCounted\r\n  local mode -- state variable that points to various decoders\r\n  local bytesLeft -- For counted decoder\r\n\r\n  -- This state is for decoding the status line and headers.\r\n  function decodeHead(chunk, index)\r\n    if not chunk or index > #chunk then return end\r\n\r\n    local _, last = find(chunk, \"\\r?\\n\\r?\\n\", index)\r\n    -- First make sure we have all the head before continuing\r\n    if not last then\r\n      if (#chunk - index) <= 8 * 1024 then return end\r\n      -- But protect against evil clients by refusing heads over 8K long.\r\n      error(\"entity too large\")\r\n    end\r\n\r\n    -- Parse the status/request line\r\n    local head = {}\r\n    local _, offset\r\n    local version\r\n    _, offset, version, head.code, head.reason =\r\n      find(chunk, \"^HTTP/(%d%.%d) (%d+) ([^\\r\\n]*)\\r?\\n\", index)\r\n    if offset then\r\n      head.code = tonumber(head.code)\r\n    else\r\n      _, offset, head.method, head.path, version =\r\n        find(chunk, \"^(%u+) ([^ ]+) HTTP/(%d%.%d)\\r?\\n\", index)\r\n      if not offset then\r\n        error(\"expected HTTP data\")\r\n      end\r\n    end\r\n    version = tonumber(version)\r\n    head.version = version\r\n    head.keepAlive = version > 1.0\r\n\r\n    -- We need to inspect some headers to know how to parse the body.\r\n    local contentLength\r\n    local chunkedEncoding\r\n\r\n    -- Parse the header lines\r\n    while true do\r\n      local key, value\r\n      _, offset, key, value = find(chunk, \"^([^:\\r\\n]+): *([^\\r\\n]*)\\r?\\n\", offset + 1)\r\n      if not offset then break end\r\n      local lowerKey = lower(key)\r\n\r\n      -- Inspect a few headers and remember the values\r\n      if lowerKey == \"content-length\" then\r\n        contentLength = tonumber(value)\r\n      elseif lowerKey == \"transfer-encoding\" then\r\n        chunkedEncoding = lower(value) == \"chunked\"\r\n      elseif lowerKey == \"connection\" then\r\n        head.keepAlive = lower(value) == \"keep-alive\"\r\n      end\r\n      head[#head + 1] = {key, value}\r\n    end\r\n\r\n    if head.keepAlive and (not (chunkedEncoding or (contentLength and contentLength > 0)))\r\n       or (head.method == \"GET\" or head.method == \"HEAD\") then\r\n      mode = decodeEmpty\r\n    elseif chunkedEncoding then\r\n      mode = decodeChunked\r\n    elseif contentLength then\r\n      bytesLeft = contentLength\r\n      mode = decodeCounted\r\n    elseif not head.keepAlive then\r\n      mode = decodeRaw\r\n    end\r\n    return head, last + 1\r\n\r\n  end\r\n\r\n  -- This is used for inserting a single empty string into the output string for known empty bodies\r\n  function decodeEmpty(chunk, index)\r\n    mode = decodeHead\r\n    return \"\", index\r\n  end\r\n\r\n  function decodeRaw(chunk, index)\r\n    if #chunk < index then return end\r\n    return sub(chunk, index)\r\n  end\r\n\r\n  function decodeChunked(chunk, index)\r\n    local len, term\r\n    len, term = match(chunk, \"^(%x+)(..)\", index)\r\n    if not len then return end\r\n    if term ~= \"\\r\\n\" then\r\n      -- Wait for full chunk-size\\r\\n header\r\n      if #chunk < 18 then return end\r\n      -- But protect against evil clients by refusing chunk-sizes longer than 16 hex digits.\r\n      error(\"chunk-size field too large\")\r\n    end\r\n    index = index + #len + 2\r\n    local offset = index - 1\r\n    local length = tonumber(len, 16)\r\n    if #chunk < offset + length + 2 then return end\r\n    if length == 0 then\r\n      mode = decodeHead\r\n    end\r\n    assert(sub(chunk, index + length, index + length + 1) == \"\\r\\n\")\r\n    local piece = sub(chunk, index, index + length - 1)\r\n    return piece, index + length + 2\r\n  end\r\n\r\n  function decodeCounted(chunk, index)\r\n    if bytesLeft == 0 then\r\n      mode = decodeEmpty\r\n      return mode(chunk, index)\r\n    end\r\n    local offset = index - 1\r\n    local length = #chunk - offset\r\n    -- Make sure we have at least one byte to process\r\n    if length == 0 then return end\r\n\r\n    -- If there isn't enough data left, emit what we got so far\r\n    if length < bytesLeft then\r\n      bytesLeft = bytesLeft - length\r\n      return sub(chunk, index)\r\n    end\r\n\r\n    mode = decodeEmpty\r\n    return sub(chunk, index, offset + bytesLeft), index + bytesLeft\r\n  end\r\n\r\n  -- Switch between states by changing which decoder mode points to\r\n  mode = decodeHead\r\n  return function (chunk, index)\r\n    return mode(chunk, index)\r\n  end\r\n\r\nend\r\n\r\nreturn {\r\n  encoder = encoder,\r\n  decoder = decoder,\r\n}","ga.duacord.http.Libraries.secure-socket.package":"return {\n  name = \"luvit/secure-socket\",\n  version = \"1.2.3\",\n  homepage = \"https://github.com/luvit/luvit/blob/master/deps/secure-socket\",\n  description = \"Wrapper for luv streams to apply ssl/tls\",\n  dependencies = {\n    \"luvit/resource@2.1.0\"\n  },\n  tags = {\"ssl\", \"socket\",\"tls\"},\n  license = \"Apache 2\",\n  author = { name = \"Tim Caswell\" }\n}\n","ga.duacord.http.Libraries.secure-socket.biowrap":"--[[\n\nCopyright 2016 The Luvit Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS-IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n--]]\nlocal openssl = require('openssl')\n\n-- writeCipher is called when ssl needs something written on the socket\n-- handshakeComplete is called when the handhake is complete and it's safe\n-- onPlain is called when plaintext comes out.\nreturn function (ctx, isServer, socket, handshakeComplete, servername)\n\n  local bin, bout = openssl.bio.mem(8192), openssl.bio.mem(8192)\n  local ssl = ctx:ssl(bin, bout, isServer)\n\n  if not isServer and servername then\n      ssl:set('hostname', servername)\n  end\n\n  local ssocket = {tls=true}\n  local onPlain\n\n  local function flush(callback)\n    local chunks = {}\n    local i = 0\n    while bout:pending() > 0 do\n      i = i + 1\n      chunks[i] = bout:read()\n    end\n    if i == 0 then\n      if callback then callback() end\n      return true\n    end\n    return socket:write(chunks, callback)\n  end\n\n  local function handshake(callback)\n    if ssl:handshake() then\n      local success, result = ssl:getpeerverification()\n      socket:read_stop()\n      if not success and result then\n        handshakeComplete(\"Error verifying peer: \" .. result[1].error_string)\n      end\n      handshakeComplete(nil, ssocket)\n    end\n    return flush(callback)\n  end\n\n  local function onCipher(err, data)\n    if not onPlain then\n      if err or not data then\n        return handshakeComplete(err or \"Peer aborted the SSL handshake\", data)\n      end\n      bin:write(data)\n      return handshake()\n    end\n    if err or not data then\n      return onPlain(err, data)\n    end\n    bin:write(data)\n    while  true do\n      local plain = ssl:read()\n      if not plain then break end\n      onPlain(nil, plain)\n    end\n  end\n\n  -- When requested to start reading, start the real socket and setup\n  -- onPlain handler\n  function ssocket.read_start(_, onRead)\n    onPlain = onRead\n    return socket:read_start(onCipher)\n  end\n\n  -- When requested to write plain data, encrypt it and write to socket\n  function ssocket.write(_, plain, callback)\n    ssl:write(plain)\n    return flush(callback)\n  end\n\n  function ssocket.shutdown(_, ...)\n    return socket:shutdown(...)\n  end\n  function ssocket.read_stop(_, ...)\n    return socket:read_stop(...)\n  end\n  function ssocket.is_closing(_, ...)\n    return socket:is_closing(...)\n  end\n  function ssocket.close(_, ...)\n    return socket:close(...)\n  end\n  function ssocket.unref(_, ...)\n    return socket:unref(...)\n  end\n  function ssocket.ref(_, ...)\n    return socket:ref(...)\n  end\n\n  handshake()\n  socket:read_start(onCipher)\n\nend\n","ga.duacord.http.Main":"local Logger = Import(\"nl.cubic-inc.logger.Main\")\r\n\r\nif FS.existsSync(\"./HTTP-Key.dat\") == false then\r\n  Logger.Info(\"Downloading SSH key\")\r\n  local Commands = {\r\n    [\"Windows\"] = \"PowerShell -Command Invoke-WebRequest http://github.com/luvit/lit/blob/master/deps/secure-socket/root_ca.dat?raw=true -o HTTP-Key.dat\"\r\n  }\r\n  \r\n  local Handle = io.popen(Commands[RuntimeOS])\r\n  Handle:close()  \r\nend\r\n\r\n\r\nlocal Modules = {\r\n  [\"base64\"] = Import(\"ga.duacord.http.Libraries.base64\"),\r\n  [\"coro-channel\"] = Import(\"ga.duacord.http.Libraries.coro-channel\"),\r\n  [\"coro-http\"] = Import(\"ga.duacord.http.Libraries.coro-http\"),\r\n  [\"coro-net\"] = Import(\"ga.duacord.http.Libraries.coro-net\"),\r\n  [\"coro-websocket\"] = Import(\"ga.duacord.http.Libraries.coro-websocket\"),\r\n  [\"coro-wrapper\"] = Import(\"ga.duacord.http.Libraries.coro-wrapper\"),\r\n  [\"http-codec\"] = Import(\"ga.duacord.http.Libraries.http-codec\"),\r\n  [\"sha1\"] = Import(\"ga.duacord.http.Libraries.sha1\"),\r\n  [\"websocket-codec\"] = Import(\"ga.duacord.http.Libraries.websocket-codec\")\r\n}\r\n\r\nreturn Modules","ga.duacord.http.Libraries.coro-channel":"--[[lit-meta\r\n  name = \"creationix/coro-channel\"\r\n  version = \"3.0.3\"\r\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-channel.lua\"\r\n  description = \"An adapter for wrapping uv streams as coro-streams.\"\r\n  tags = {\"coro\", \"adapter\"}\r\n  license = \"MIT\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\n-- local p = require('pretty-print').prettyPrint\r\n\r\nlocal function assertResume(thread, ...)\r\n    local success, err = coroutine.resume(thread, ...)\r\n    if not success then\r\n      error(debug.traceback(thread, err), 0)\r\n    end\r\n  end\r\n  \r\n  local function makeCloser(socket)\r\n    local closer = {\r\n      read = false,\r\n      written = false,\r\n      errored = false,\r\n    }\r\n  \r\n    local closed = false\r\n  \r\n    local function close()\r\n      if closed then return end\r\n      closed = true\r\n      if not closer.readClosed then\r\n        closer.readClosed = true\r\n        if closer.onClose then\r\n          closer.onClose()\r\n        end\r\n      end\r\n      if not socket:is_closing() then\r\n        socket:close()\r\n      end\r\n    end\r\n  \r\n    closer.close = close\r\n  \r\n    function closer.check()\r\n      if closer.errored or (closer.read and closer.written) then\r\n        return close()\r\n      end\r\n    end\r\n  \r\n    return closer\r\n  end\r\n  \r\n  local function makeRead(socket, closer)\r\n    local paused = true\r\n  \r\n    local queue = {}\r\n    local tindex = 0\r\n    local dindex = 0\r\n  \r\n    local function dispatch(data)\r\n  \r\n      -- p(\"<-\", data[1])\r\n  \r\n      if tindex > dindex then\r\n        local thread = queue[dindex]\r\n        queue[dindex] = nil\r\n        dindex = dindex + 1\r\n        assertResume(thread, unpack(data))\r\n      else\r\n        queue[dindex] = data\r\n        dindex = dindex + 1\r\n        if not paused then\r\n          paused = true\r\n          assert(socket:read_stop())\r\n        end\r\n      end\r\n    end\r\n  \r\n    closer.onClose = function ()\r\n      if not closer.read then\r\n        closer.read = true\r\n        return dispatch {nil, closer.errored}\r\n      end\r\n    end\r\n  \r\n    local function onRead(err, chunk)\r\n      if err then\r\n        closer.errored = err\r\n        return closer.check()\r\n      end\r\n      if not chunk then\r\n        if closer.read then return end\r\n        closer.read = true\r\n        dispatch {}\r\n        return closer.check()\r\n      end\r\n      return dispatch {chunk}\r\n    end\r\n  \r\n    local function read()\r\n      if dindex > tindex then\r\n        local data = queue[tindex]\r\n        queue[tindex] = nil\r\n        tindex = tindex + 1\r\n        return unpack(data)\r\n      end\r\n      if paused then\r\n        paused = false\r\n        assert(socket:read_start(onRead))\r\n      end\r\n      queue[tindex] = coroutine.running()\r\n      tindex = tindex + 1\r\n      return coroutine.yield()\r\n    end\r\n  \r\n    -- Auto use wrapper library for backwards compat\r\n    return read\r\n  end\r\n  \r\n  local function makeWrite(socket, closer)\r\n  \r\n    local function wait()\r\n      local thread = coroutine.running()\r\n      return function (err)\r\n        assertResume(thread, err)\r\n      end\r\n    end\r\n  \r\n    local function write(chunk)\r\n      if closer.written then\r\n        return nil, \"already shutdown\"\r\n      end\r\n  \r\n      -- p(\"->\", chunk)\r\n  \r\n      if chunk == nil then\r\n        closer.written = true\r\n        closer.check()\r\n        local success, err = socket:shutdown(wait())\r\n        if not success then\r\n          return nil, err\r\n        end\r\n        err = coroutine.yield()\r\n        return not err, err\r\n      end\r\n  \r\n      local success, err = socket:write(chunk, wait())\r\n      if not success then\r\n        closer.errored = err\r\n        closer.check()\r\n        return nil, err\r\n      end\r\n      err = coroutine.yield()\r\n      return not err, err\r\n    end\r\n  \r\n    return write\r\n  end\r\n  \r\n  local function wrapRead(socket)\r\n    local closer = makeCloser(socket)\r\n    closer.written = true\r\n    return makeRead(socket, closer), closer.close\r\n  end\r\n  \r\n  local function wrapWrite(socket)\r\n    local closer = makeCloser(socket)\r\n    closer.read = true\r\n    return makeWrite(socket, closer), closer.close\r\n  end\r\n  \r\n  local function wrapStream(socket)\r\n    assert(socket\r\n      and socket.write\r\n      and socket.shutdown\r\n      and socket.read_start\r\n      and socket.read_stop\r\n      and socket.is_closing\r\n      and socket.close, \"socket does not appear to be a socket/uv_stream_t\")\r\n  \r\n    local closer = makeCloser(socket)\r\n    return makeRead(socket, closer), makeWrite(socket, closer), closer.close\r\n  end\r\n  \r\n  return {\r\n    wrapRead = wrapRead,\r\n    wrapWrite = wrapWrite,\r\n    wrapStream = wrapStream,\r\n  }","ga.duacord.http.Libraries.secure-socket.init":"--[[\r\n\r\nCopyright 2016 The Luvit Authors. All Rights Reserved.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS-IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n\r\n--]]\r\nlocal getContext = Import(\"ga.duacord.http.Libraries.secure-socket.context\")\r\nlocal bioWrap = Import(\"ga.duacord.http.Libraries.secure-socket.biowrap\")\r\n\r\nlocal function assertResume(thread, ...)\r\n  local success, err = coroutine.resume(thread, ...)\r\n  if not success then\r\n    error(debug.traceback(thread, err), 0)\r\n  end\r\nend\r\n\r\nreturn function (socket, options, callback)\r\n  if options == true then options = {} end\r\n  local ctx = getContext(options)\r\n  local thread\r\n  if not callback then\r\n    thread = coroutine.running()\r\n  end\r\n  bioWrap(ctx, options.server, socket, callback or function (err, ssocket)\r\n    return assertResume(thread, ssocket, err)\r\nend, options.servername)\r\n  if not callback then\r\n    return coroutine.yield()\r\n  end\r\nend\r\n","ga.duacord.http.Libraries.pathjoin":"--[[lit-meta\r\n  name = \"creationix/pathjoin\"\r\n  description = \"The path utilities that used to be part of luvi\"\r\n  version = \"2.0.0\"\r\n  tags = {\"path\"}\r\n  license = \"MIT\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\nlocal getPrefix, splitPath, joinParts\r\n\r\nlocal isWindows\r\nif _G.jit then\r\n  isWindows = _G.jit.os == \"Windows\"\r\nelse\r\n  isWindows = not not package.path:match(\"\\\\\")\r\nend\r\n\r\nif isWindows then\r\n  -- Windows aware path utilities\r\n  function getPrefix(path)\r\n    return path:match(\"^%a:\\\\\") or\r\n           path:match(\"^/\") or\r\n           path:match(\"^\\\\+\")\r\n  end\r\n  function splitPath(path)\r\n    local parts = {}\r\n    for part in string.gmatch(path, '([^/\\\\]+)') do\r\n      table.insert(parts, part)\r\n    end\r\n    return parts\r\n  end\r\n  function joinParts(prefix, parts, i, j)\r\n    if not prefix then\r\n      return table.concat(parts, '/', i, j)\r\n    elseif prefix ~= '/' then\r\n      return prefix .. table.concat(parts, '\\\\', i, j)\r\n    else\r\n      return prefix .. table.concat(parts, '/', i, j)\r\n    end\r\n  end\r\nelse\r\n  -- Simple optimized versions for UNIX systems\r\n  function getPrefix(path)\r\n    return path:match(\"^/\")\r\n  end\r\n  function splitPath(path)\r\n    local parts = {}\r\n    for part in string.gmatch(path, '([^/]+)') do\r\n      table.insert(parts, part)\r\n    end\r\n    return parts\r\n  end\r\n  function joinParts(prefix, parts, i, j)\r\n    if prefix then\r\n      return prefix .. table.concat(parts, '/', i, j)\r\n    end\r\n    return table.concat(parts, '/', i, j)\r\n  end\r\nend\r\n\r\nlocal function pathJoin(...)\r\n  local inputs = {...}\r\n  local l = #inputs\r\n\r\n  -- Find the last segment that is an absolute path\r\n  -- Or if all are relative, prefix will be nil\r\n  local i = l\r\n  local prefix\r\n  while true do\r\n    prefix = getPrefix(inputs[i])\r\n    if prefix or i <= 1 then break end\r\n    i = i - 1\r\n  end\r\n\r\n  -- If there was one, remove its prefix from its segment\r\n  if prefix then\r\n    inputs[i] = inputs[i]:sub(#prefix)\r\n  end\r\n\r\n  -- Split all the paths segments into one large list\r\n  local parts = {}\r\n  while i <= l do\r\n    local sub = splitPath(inputs[i])\r\n    for j = 1, #sub do\r\n      parts[#parts + 1] = sub[j]\r\n    end\r\n    i = i + 1\r\n  end\r\n\r\n  -- Evaluate special segments in reverse order.\r\n  local skip = 0\r\n  local reversed = {}\r\n  for idx = #parts, 1, -1 do\r\n    local part = parts[idx]\r\n    if part ~= '.' then\r\n      if part == '..' then\r\n        skip = skip + 1\r\n      elseif skip > 0 then\r\n        skip = skip - 1\r\n      else\r\n        reversed[#reversed + 1] = part\r\n      end\r\n    end\r\n  end\r\n\r\n  -- Reverse the list again to get the correct order\r\n  parts = reversed\r\n  for idx = 1, #parts / 2 do\r\n    local j = #parts - idx + 1\r\n    parts[idx], parts[j] = parts[j], parts[idx]\r\n  end\r\n\r\n  local path = joinParts(prefix, parts)\r\n  return path\r\nend\r\n\r\nreturn {\r\n  isWindows = isWindows,\r\n  getPrefix = getPrefix,\r\n  splitPath = splitPath,\r\n  joinParts = joinParts,\r\n  pathJoin = pathJoin,\r\n}","ga.duacord.http.Libraries.sha1":"--[[lit-meta\r\n  name = \"creationix/sha1\"\r\n  version = \"1.0.4\"\r\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/sha1.lua\"\r\n  description = \"Pure Lua implementation of SHA1 using bitop\"\r\n  authors = {\r\n    \"Tim Caswell\"\r\n  }\r\n]]\r\n\r\n-- http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA_All.pdf\r\n\r\nlocal bit = require('bit')\r\nlocal band = bit.band\r\nlocal bor = bit.bor\r\nlocal bxor = bit.bxor\r\nlocal lshift = bit.lshift\r\nlocal rshift = bit.rshift\r\nlocal rol = bit.rol\r\nlocal tobit = bit.tobit\r\nlocal tohex = bit.tohex\r\n\r\nlocal byte = string.byte\r\nlocal concat = table.concat\r\nlocal floor = table.floor\r\n\r\nlocal hasFFi, ffi = pcall(require, \"ffi\")\r\nlocal newBlock = hasFFi and function ()\r\n  return ffi.new(\"uint32_t[80]\")\r\nend or function ()\r\n  local t = {}\r\n  for i = 0, 79 do\r\n    t[i] = 0\r\n  end\r\n  return t\r\nend\r\n\r\nlocal shared = newBlock()\r\n\r\nlocal function unsigned(n)\r\n  return n < 0 and (n + 0x100000000) or n\r\nend\r\n\r\nlocal function create(sync)\r\n  local h0 = 0x67452301\r\n  local h1 = 0xEFCDAB89\r\n  local h2 = 0x98BADCFE\r\n  local h3 = 0x10325476\r\n  local h4 = 0xC3D2E1F0\r\n  -- The first 64 bytes (16 words) is the data chunk\r\n  local W = sync and shared or newBlock()\r\n  local offset = 0\r\n  local shift = 24\r\n  local totalLength = 0\r\n\r\n  local update, write, processBlock, digest\r\n\r\n  -- The user gave us more data.  Store it!\r\n  function update(chunk)\r\n    local length = #chunk\r\n    totalLength = totalLength + length * 8\r\n    for i = 1, length do\r\n      write(byte(chunk, i))\r\n    end\r\n  end\r\n\r\n  function write(data)\r\n    W[offset] = bor(W[offset], lshift(band(data, 0xff), shift))\r\n    if shift > 0 then\r\n      shift = shift - 8\r\n    else\r\n      offset = offset + 1\r\n      shift = 24\r\n    end\r\n    if offset == 16 then\r\n      return processBlock()\r\n    end\r\n  end\r\n\r\n  -- No more data will come, pad the block, process and return the result.\r\n  function digest()\r\n    -- Pad\r\n    write(0x80)\r\n    if offset > 14 or (offset == 14 and shift < 24) then\r\n      processBlock()\r\n    end\r\n    offset = 14\r\n    shift = 24\r\n\r\n    -- 64-bit length big-endian\r\n    write(0x00) -- numbers this big aren't accurate in lua anyway\r\n    write(0x00) -- ..So just hard-code to zero.\r\n    write(totalLength > 0xffffffffff and floor(totalLength / 0x10000000000) or 0x00)\r\n    write(totalLength > 0xffffffff and floor(totalLength / 0x100000000) or 0x00)\r\n    for s = 24, 0, -8 do\r\n      write(rshift(totalLength, s))\r\n    end\r\n\r\n    -- At this point one last processBlock() should trigger and we can pull out the result.\r\n    return concat {\r\n      tohex(h0),\r\n      tohex(h1),\r\n      tohex(h2),\r\n      tohex(h3),\r\n      tohex(h4)\r\n    }\r\n  end\r\n\r\n  -- We have a full block to process.  Let's do it!\r\n  function processBlock()\r\n\r\n    -- Extend the sixteen 32-bit words into eighty 32-bit words:\r\n    for i = 16, 79, 1 do\r\n      W[i] =\r\n        rol(bxor(W[i - 3], W[i - 8], W[i - 14], W[i - 16]), 1)\r\n    end\r\n\r\n    -- print(\"Block Contents:\")\r\n    -- for i = 0, 15 do\r\n    --   print(string.format(\"  W[%d] = %s\", i, tohex(W[i])))\r\n    -- end\r\n    -- print()\r\n\r\n    -- Initialize hash value for this chunk:\r\n    local a = h0\r\n    local b = h1\r\n    local c = h2\r\n    local d = h3\r\n    local e = h4\r\n    local f, k\r\n\r\n    -- print(\"         A         B         C         D         E\")\r\n    -- local format =\r\n    --   \"t=%02d: %s  %s  %s  %s  %s\"\r\n    -- Main loop:\r\n    for t = 0, 79 do\r\n      if t < 20 then\r\n        f = bxor(d, band(b, bxor(c, d)))\r\n        k = 0x5A827999\r\n      elseif t < 40 then\r\n        f = bxor(b, c, d)\r\n        k = 0x6ED9EBA1\r\n      elseif t < 60 then\r\n        f = bor(band(b, c), (band(d, bor(b, c))))\r\n        k = 0x8F1BBCDC\r\n      else\r\n        f = bxor(b, c, d)\r\n        k = 0xCA62C1D6\r\n      end\r\n      e, d, c, b, a =\r\n        d,\r\n        c,\r\n        rol(b, 30),\r\n        a,\r\n        tobit(\r\n          unsigned(rol(a, 5)) +\r\n          unsigned(f) +\r\n          unsigned(e) +\r\n          unsigned(k) +\r\n          W[t]\r\n        )\r\n      -- print(string.format(format, t, tohex(a), tohex(b), tohex(c), tohex(d), tohex(e)))\r\n    end\r\n\r\n    -- Add this chunk's hash to result so far:\r\n    h0 = tobit(unsigned(h0) + a)\r\n    h1 = tobit(unsigned(h1) + b)\r\n    h2 = tobit(unsigned(h2) + c)\r\n    h3 = tobit(unsigned(h3) + d)\r\n    h4 = tobit(unsigned(h4) + e)\r\n\r\n    -- The block is now reusable.\r\n    offset = 0\r\n    for i = 0, 15 do\r\n      W[i] = 0\r\n    end\r\n  end\r\n\r\n  return {\r\n    update = update,\r\n    digest = digest\r\n  }\r\n\r\nend\r\n\r\nreturn function (buffer)\r\n  -- Pass in false or nil to get a streaming interface.\r\n  if not buffer then\r\n    return create(false)\r\n  end\r\n  local shasum = create(true)\r\n  shasum.update(buffer)\r\n  return shasum.digest()\r\nend","ga.duacord.http.Libraries.secure-socket.context":"--[[\r\n\r\nCopyright 2016 The Luvit Authors. All Rights Reserved.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS-IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n\r\n--]]\r\nlocal openssl = require('openssl')\r\n\r\nlocal bit = require('bit')\r\n\r\nlocal DEFAULT_SECUREPROTOCOL\r\ndo\r\n  local _, _, V = openssl.version()\r\n  local isLibreSSL = V:find('^LibreSSL')\r\n\r\n  _, _, V = openssl.version(true)\r\n  local isTLSv1_3 = not isLibreSSL and V >= 0x10101000\r\n\r\n  if isTLSv1_3 then\r\n    DEFAULT_SECUREPROTOCOL = 'TLS'\r\n  else\r\n    DEFAULT_SECUREPROTOCOL = 'SSLv23'\r\n  end\r\nend\r\nlocal DEFAULT_CIPHERS = 'TLS_AES_128_GCM_SHA256:TLS_AES_128_CCM_SHA256:' .. --TLS 1.3\r\n                        'ECDHE-RSA-AES128-SHA256:AES128-GCM-SHA256:' ..     --TLS 1.2\r\n                        'RC4:HIGH:!MD5:!aNULL:!EDH'                         --TLS 1.0\r\nlocal DEFAULT_CA_STORE\r\ndo\r\n  local data = assert(FS.readFileSync(\"HTTP-Key.dat\"))\r\n  DEFAULT_CA_STORE = openssl.x509.store:new()\r\n  local index = 1\r\n  local dataLength = #data\r\n  while index < dataLength do\r\n    local len = bit.bor(bit.lshift(data:byte(index), 8), data:byte(index + 1))\r\n    index = index + 2\r\n    local cert = assert(openssl.x509.read(data:sub(index, index + len)))\r\n    index = index + len\r\n    assert(DEFAULT_CA_STORE:add(cert))\r\n  end\r\nend\r\n\r\nlocal function returnOne()\r\n  return 1\r\nend\r\n\r\nreturn function (options)\r\n  local ctx = openssl.ssl.ctx_new(\r\n    options.protocol or DEFAULT_SECUREPROTOCOL,\r\n    options.ciphers or DEFAULT_CIPHERS)\r\n\r\n  local key, cert, ca\r\n  if options.key then\r\n    key = assert(openssl.pkey.read(options.key, true, 'pem'))\r\n  end\r\n  if options.cert then\r\n    cert = {}\r\n    for chunk in options.cert:gmatch(\"%-+BEGIN[^-]+%-+[^-]+%-+END[^-]+%-+\") do\r\n      cert[#cert + 1] = assert(openssl.x509.read(chunk))\r\n    end\r\n  end\r\n  if options.ca then\r\n    if type(options.ca) == \"string\" then\r\n      ca = { assert(openssl.x509.read(options.ca)) }\r\n    elseif type(options.ca) == \"table\" then\r\n      ca = {}\r\n      for i = 1, #options.ca do\r\n        ca[i] = assert(openssl.x509.read(options.ca[i]))\r\n      end\r\n    else\r\n      error(\"options.ca must be string or table of strings\")\r\n    end\r\n  end\r\n  if key and cert then\r\n    local first = table.remove(cert, 1)\r\n    assert(ctx:use(key, first))\r\n    if #cert > 0 then\r\n      -- TODO: find out if there is a way to not need to duplicate the last cert here\r\n      -- as a dummy fill for the root CA cert\r\n      assert(ctx:add(cert[#cert], cert))\r\n    end\r\n  end\r\n  if ca then\r\n    local store = openssl.x509.store:new()\r\n    for i = 1, #ca do\r\n      assert(store:add(ca[i]))\r\n    end\r\n    ctx:cert_store(store)\r\n  elseif DEFAULT_CA_STORE then\r\n    ctx:cert_store(DEFAULT_CA_STORE)\r\n  end\r\n  if not (options.insecure or options.key) then\r\n    ctx:verify_mode(openssl.ssl.peer, returnOne)\r\n  end\r\n\r\n  ctx:options(bit.bor(\r\n    openssl.ssl.no_sslv2,\r\n    openssl.ssl.no_sslv3,\r\n    openssl.ssl.no_compression))\r\n\r\n  return ctx\r\nend\r\n","ga.duacord.http.Libraries.coro-websocket":"--[[lit-meta\r\n  name = \"creationix/coro-websocket\"\r\n  version = \"3.1.1\"\r\n  dependencies = {\r\n    \"luvit/http-codec@3.0.0\",\r\n    \"creationix/websocket-codec@3.0.0\",\r\n    \"creationix/coro-net@3.3.0\",\r\n  }\r\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-websocket.lua\"\r\n  description = \"Websocket helpers assuming coro style I/O.\"\r\n  tags = {\"coro\", \"websocket\"}\r\n  license = \"MIT\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\nlocal uv = require('uv')\r\nlocal httpCodec = Import(\"ga.duacord.http.Libraries.http-codec\")\r\nlocal websocketCodec = Import(\"ga.duacord.http.Libraries.websocket-codec\")\r\nlocal net = Import(\"ga.duacord.http.Libraries.coro-net\")\r\n\r\nlocal function parseUrl(url)\r\n  local protocol, host, port, pathname = string.match(url, \"^(wss?)://([^:/]+):?(%d*)(/?[^#?]*)\")\r\n  local tls\r\n  if protocol == \"ws\" then\r\n    port = tonumber(port) or 80\r\n    tls = false\r\n  elseif protocol == \"wss\" then\r\n    port = tonumber(port) or 443\r\n    tls = true\r\n  else\r\n    return nil, \"Sorry, only ws:// or wss:// protocols supported\"\r\n  end\r\n  return {\r\n    host = host,\r\n    port = port,\r\n    tls = tls,\r\n    pathname = pathname\r\n  }\r\nend\r\n\r\nlocal function wrapIo(rawRead, rawWrite, options)\r\n\r\n  local closeSent = false\r\n\r\n  local timer\r\n\r\n  local function cleanup()\r\n    if timer then\r\n      if not timer:is_closing() then\r\n        timer:close()\r\n      end\r\n      timer = nil\r\n    end\r\n  end\r\n\r\n  local function write(message)\r\n    if message then\r\n      message.mask = options.mask\r\n      if message.opcode == 8 then\r\n        closeSent = true\r\n        rawWrite(message)\r\n        cleanup()\r\n        return rawWrite()\r\n      end\r\n    else\r\n      if not closeSent then\r\n        return write({\r\n          opcode = 8,\r\n          payload = \"\"\r\n        })\r\n      end\r\n    end\r\n    return rawWrite(message)\r\n  end\r\n\r\n\r\n  local function read()\r\n    while true do\r\n      local message = rawRead()\r\n      if not message then\r\n        return cleanup()\r\n      end\r\n      if message.opcode < 8 then\r\n        return message\r\n      end\r\n      if not closeSent then\r\n        if message.opcode == 8 then\r\n          write {\r\n            opcode = 8,\r\n            payload = message.payload\r\n          }\r\n        elseif message.opcode == 9 then\r\n          write {\r\n            opcode = 10,\r\n            payload = message.payload\r\n          }\r\n        end\r\n        return message\r\n      end\r\n    end\r\n  end\r\n\r\n  if options.heartbeat then\r\n    local interval = options.heartbeat\r\n    timer = uv.new_timer()\r\n    timer:unref()\r\n    timer:start(interval, interval, function ()\r\n      coroutine.wrap(function ()\r\n        local success, err = write {\r\n          opcode = 10,\r\n          payload = \"\"\r\n        }\r\n        if not success then\r\n          timer:close()\r\n          print(err)\r\n        end\r\n      end)()\r\n    end)\r\n  end\r\n\r\n  return read, write\r\nend\r\n\r\n-- options table to configure connection\r\n--   options.path\r\n--   options.host\r\n--   options.port\r\n--   options.tls\r\n--   options.pathname\r\n--   options.subprotocol\r\n--   options.headers (as list of header/value pairs)\r\n--   options.timeout\r\n--   options.heartbeat\r\n-- returns res, read, write (res.socket has socket)\r\nlocal function connect(options)\r\n  options = options or {}\r\n  local config = {\r\n    path = options.path,\r\n    host = options.host,\r\n    port = options.port,\r\n    tls = options.tls,\r\n    encoder = httpCodec.encoder,\r\n    decoder = httpCodec.decoder,\r\n  }\r\n  local read, write, socket, updateDecoder, updateEncoder\r\n    = net.connect(config, options.timeout or 10000)\r\n  if not read then\r\n    return nil, write\r\n  end\r\n\r\n  local res\r\n\r\n  local success, err = websocketCodec.handshake({\r\n    host = options.host,\r\n    path = options.pathname,\r\n    protocol = options.subprotocol\r\n  }, function (req)\r\n    local headers = options.headers\r\n    if headers then\r\n      for i = 1, #headers do\r\n        req[#req + 1] = headers[i]\r\n      end\r\n    end\r\n    write(req)\r\n    res = read()\r\n    if not res then error(\"Missing server response\") end\r\n    if res.code == 400 then\r\n      -- p { req = req, res = res }\r\n      local reason = read() or res.reason\r\n      error(\"Invalid request: \" .. reason)\r\n    end\r\n    return res\r\n  end)\r\n  if not success then\r\n    return nil, err\r\n  end\r\n\r\n  -- Upgrade the protocol to websocket\r\n  updateDecoder(websocketCodec.decode)\r\n  updateEncoder(websocketCodec.encode)\r\n\r\n  read, write = wrapIo(read, write, {\r\n    mask = true,\r\n    heartbeat = options.heartbeat\r\n  })\r\n\r\n  res.socket = socket\r\n  return res, read, write\r\n\r\nend\r\n\r\nreturn {\r\n  parseUrl = parseUrl,\r\n  wrapIo = wrapIo,\r\n  connect = connect,\r\n}","ga.duacord.http.Libraries.coro-http":"--[[lit-meta\r\n  name = \"creationix/coro-http\"\r\n  version = \"3.2.3\"\r\n  dependencies = {\r\n    \"creationix/coro-net@3.3.0\",\r\n    \"luvit/http-codec@3.0.0\"\r\n  }\r\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-http.lua\"\r\n  description = \"An coro style http(s) client and server helper.\"\r\n  tags = {\"coro\", \"http\"}\r\n  license = \"MIT\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\nlocal httpCodec = Import(\"ga.duacord.http.Libraries.http-codec\")\r\nlocal net = Import(\"ga.duacord.http.Libraries.coro-net\")\r\n\r\nlocal function createServer(host, port, onConnect)\r\n  return net.createServer({\r\n    host = host,\r\n    port = port,\r\n    encoder = httpCodec.encoder,\r\n    decoder = httpCodec.decoder,\r\n  }, function (read, write, socket)\r\n    for head in read do\r\n      local parts = {}\r\n      for part in read do\r\n        if #part > 0 then\r\n          parts[#parts + 1] = part\r\n        else\r\n          break\r\n        end\r\n      end\r\n      local body = table.concat(parts)\r\n      head, body = onConnect(head, body, socket)\r\n      write(head)\r\n      if body then write(body) end\r\n      write(\"\")\r\n      if not head.keepAlive then break end\r\n    end\r\n    write()\r\n  end)\r\nend\r\n\r\nlocal function parseUrl(url)\r\n  local protocol, host, hostname, port, path = url:match(\"^(https?:)//(([^/:]+):?([0-9]*))(/?.*)$\")\r\n  if not protocol then error(\"Not a valid http url: \" .. url) end\r\n  local tls = protocol == \"https:\"\r\n  port = port and tonumber(port) or (tls and 443 or 80)\r\n  if path == \"\" then path = \"/\" end\r\n  return {\r\n    tls = tls,\r\n    host = host,\r\n    hostname = hostname,\r\n    port = port,\r\n    path = path\r\n  }\r\nend\r\n\r\nlocal connections = {}\r\n\r\nlocal function getConnection(host, port, tls, timeout)\r\n  for i = #connections, 1, -1 do\r\n    local connection = connections[i]\r\n    if connection.host == host and connection.port == port and connection.tls == tls then\r\n      table.remove(connections, i)\r\n      -- Make sure the connection is still alive before reusing it.\r\n      if not connection.socket:is_closing() then\r\n        connection.reused = true\r\n        connection.socket:ref()\r\n        return connection\r\n      end\r\n    end\r\n  end\r\n  local read, write, socket, updateDecoder, updateEncoder = assert(net.connect {\r\n    host = host,\r\n    port = port,\r\n    tls = tls,\r\n    timeout = timeout,\r\n    encoder = httpCodec.encoder,\r\n    decoder = httpCodec.decoder\r\n  })\r\n  return {\r\n    socket = socket,\r\n    host = host,\r\n    port = port,\r\n    tls = tls,\r\n    read = read,\r\n    write = write,\r\n    updateEncoder = updateEncoder,\r\n    updateDecoder = updateDecoder,\r\n    reset = function ()\r\n      -- This is called after parsing the response head from a HEAD request.\r\n      -- If you forget, the codec might hang waiting for a body that doesn't exist.\r\n      updateDecoder(httpCodec.decoder())\r\n    end\r\n  }\r\nend\r\n\r\nlocal function saveConnection(connection)\r\n  if connection.socket:is_closing() then return end\r\n  connections[#connections + 1] = connection\r\n  connection.socket:unref()\r\nend\r\n\r\nlocal function request(method, url, headers, body, customOptions)\r\n  -- customOptions = { timeout = number, followRedirects = boolean }\r\n  local options = {}\r\n  if type(customOptions) == \"number\" then\r\n    -- Ensure backwards compatibility, where customOptions used to just be timeout\r\n    options.timeout = customOptions\r\n  else\r\n    options = customOptions or {}\r\n  end\r\n  options.followRedirects = options.followRedirects == nil and true or options.followRedirects -- Follow any redirects, Default: true\r\n\r\n  local uri = parseUrl(url)\r\n  local connection = getConnection(uri.hostname, uri.port, uri.tls, options.timeout)\r\n  local read = connection.read\r\n  local write = connection.write\r\n\r\n  local req = {\r\n    method = method,\r\n    path = uri.path,\r\n  }\r\n  local contentLength\r\n  local chunked\r\n  local hasHost = false\r\n  if headers then\r\n    for i = 1, #headers do\r\n      local key, value = unpack(headers[i])\r\n      key = key:lower()\r\n      if key == \"content-length\" then\r\n        contentLength = value\r\n      elseif key == \"content-encoding\" and value:lower() == \"chunked\" then\r\n        chunked = true\r\n      elseif key == \"host\" then\r\n        hasHost = true\r\n      end\r\n      req[#req + 1] = headers[i]\r\n    end\r\n  end\r\n  if not hasHost then\r\n    req[#req + 1] = {\"Host\", uri.host}\r\n  end\r\n\r\n\r\n  if type(body) == \"string\" then\r\n    if not chunked and not contentLength then\r\n      req[#req + 1] = {\"Content-Length\", #body}\r\n    end\r\n  end\r\n\r\n  write(req)\r\n  if body then write(body) end\r\n  local res = read()\r\n  if not res then\r\n    if not connection.socket:is_closing() then\r\n      connection.socket:close()\r\n    end\r\n    -- If we get an immediate close on a reused socket, try again with a new socket.\r\n    -- TODO: think about if this could resend requests with side effects and cause\r\n    -- them to double execute in the remote server.\r\n    if connection.reused then\r\n      return request(method, url, headers, body)\r\n    end\r\n    error(\"Connection closed\")\r\n  end\r\n\r\n  body = {}\r\n  if req.method == \"HEAD\" then\r\n    connection.reset()\r\n  else\r\n    while true do\r\n      local item = read()\r\n      if not item then\r\n        res.keepAlive = false\r\n        break\r\n      end\r\n      if #item == 0 then\r\n        break\r\n      end\r\n      body[#body + 1] = item\r\n    end\r\n  end\r\n\r\n  if res.keepAlive then\r\n    saveConnection(connection)\r\n  else\r\n    write()\r\n  end\r\n\r\n  -- Follow redirects\r\n  if method == \"GET\" and (res.code == 302 or res.code == 307) and options.followRedirects then\r\n    for i = 1, #res do\r\n      local key, location = unpack(res[i])\r\n      if key:lower() == \"location\" then\r\n        return request(method, location, headers)\r\n      end\r\n    end\r\n  end\r\n\r\n  return res, table.concat(body)\r\nend\r\n\r\nreturn {\r\n  createServer = createServer,\r\n  parseUrl = parseUrl,\r\n  getConnection = getConnection,\r\n  saveConnection = saveConnection,\r\n  request = request,\r\n}","ga.duacord.http.Libraries.coro-net":"--[[lit-meta\r\n  name = \"creationix/coro-net\"\r\n  version = \"3.3.0\"\r\n  dependencies = {\r\n    \"creationix/coro-channel@3.0.0\",\r\n    \"creationix/coro-wrapper@3.0.0\",\r\n  }\r\n  optionalDependencies = {\r\n    \"luvit/secure-socket@1.0.0\"\r\n  }\r\n  homepage = \"https://github.com/luvit/lit/blob/master/deps/coro-net.lua\"\r\n  description = \"An coro style client and server helper for tcp and pipes.\"\r\n  tags = {\"coro\", \"tcp\", \"pipe\", \"net\"}\r\n  license = \"MIT\"\r\n  author = { name = \"Tim Caswell\" }\r\n]]\r\n\r\nlocal uv = require('uv')\r\nlocal wrapStream = Import(\"ga.duacord.http.Libraries.coro-channel\").wrapStream\r\nlocal wrapper = Import(\"ga.duacord.http.Libraries.coro-wrapper\")\r\nlocal merger = wrapper.merger\r\nlocal decoder = wrapper.decoder\r\nlocal encoder = wrapper.encoder\r\nlocal secureSocket -- Lazy required from \"secure-socket\" on first use.\r\n\r\nlocal function assertResume(thread, ...)\r\n  local success, err = coroutine.resume(thread, ...)\r\n  if not success then\r\n    error(debug.traceback(thread, err), 0)\r\n  end\r\nend\r\n\r\nlocal function makeCallback(timeout)\r\n  local thread = coroutine.running()\r\n  local timer, done\r\n  if timeout then\r\n    timer = uv.new_timer()\r\n    timer:start(timeout, 0, function ()\r\n      if done then return end\r\n      done = true\r\n      timer:close()\r\n      return assertResume(thread, nil, \"timeout\")\r\n    end)\r\n  end\r\n  return function (err, data)\r\n    if done then return end\r\n    done = true\r\n    if timer then timer:close() end\r\n    if err then\r\n      return assertResume(thread, nil, err)\r\n    end\r\n    return assertResume(thread, data or true)\r\n  end\r\nend\r\n\r\nlocal function normalize(options, server)\r\n  local t = type(options)\r\n  if t == \"string\" then\r\n    options = {path=options}\r\n  elseif t == \"number\" then\r\n    options = {port=options}\r\n  elseif t ~= \"table\" then\r\n    assert(\"Net options must be table, string, or number\")\r\n  end\r\n  if options.port or options.host then\r\n    options.isTcp = true\r\n    options.host = options.host or \"127.0.0.1\"\r\n    assert(options.port, \"options.port is required for tcp connections\")\r\n  elseif options.path then\r\n    options.isTcp = false\r\n  else\r\n    error(\"Must set either options.path or options.port\")\r\n  end\r\n  if options.tls == true then\r\n    options.tls = {}\r\n  end\r\n  if options.tls then\r\n    if server then\r\n      options.tls.server = true\r\n      assert(options.tls.cert, \"TLS servers require a certificate\")\r\n      assert(options.tls.key, \"TLS servers require a key\")\r\n    else\r\n      options.tls.server = false\r\n      options.tls.servername = options.host\r\n    end\r\n  end\r\n  return options\r\nend\r\n\r\nlocal function connect(options)\r\n  local socket, success, err\r\n  options = normalize(options)\r\n  if options.isTcp then\r\n    success, err = uv.getaddrinfo(options.host, options.port, {\r\n      socktype = options.socktype or \"stream\",\r\n      family = options.family or \"inet\",\r\n    }, makeCallback(options.timeout))\r\n    if not success then return nil, err end\r\n    local res\r\n    res, err = coroutine.yield()\r\n    if not res then return nil, err end\r\n    socket = uv.new_tcp()\r\n    socket:connect(res[1].addr, res[1].port, makeCallback(options.timeout))\r\n  else\r\n    socket = uv.new_pipe(false)\r\n    socket:connect(options.path, makeCallback(options.timeout))\r\n  end\r\n  success, err = coroutine.yield()\r\n  if not success then return nil, err end\r\n  local dsocket\r\n  if options.tls then\r\n    if not secureSocket then secureSocket = Import(\"ga.duacord.http.Libraries.secure-socket.init\") end\r\n    dsocket, err = secureSocket(socket, options.tls)\r\n    if not dsocket then\r\n      return nil, err\r\n    end\r\n  else\r\n    dsocket = socket\r\n  end\r\n\r\n  local read, write, close = wrapStream(dsocket)\r\n  local updateDecoder, updateEncoder\r\n  if options.scan then\r\n    -- TODO: Should we expose updateScan somehow?\r\n    read = merger(read, options.scan)\r\n  end\r\n  if options.decoder then\r\n    read, updateDecoder = decoder(read, options.decoder())\r\n  elseif options.decode then\r\n    read, updateDecoder = decoder(read, options.decode)\r\n  end\r\n  if options.encoder then\r\n    write, updateEncoder = encoder(write, options.encoder())\r\n  elseif options.encode then\r\n    write, updateEncoder = encoder(write, options.encode)\r\n  end\r\n  return read, write, dsocket, updateDecoder, updateEncoder, close\r\nend\r\n\r\nlocal function createServer(options, onConnect)\r\n  local server\r\n  options = normalize(options, true)\r\n  if options.isTcp then\r\n    server = uv.new_tcp()\r\n    assert(server:bind(options.host, options.port))\r\n  else\r\n    server = uv.new_pipe(false)\r\n    assert(server:bind(options.path))\r\n  end\r\n  assert(server:listen(256, function (err)\r\n    assert(not err, err)\r\n    local socket = options.isTcp and uv.new_tcp() or uv.new_pipe(false)\r\n    server:accept(socket)\r\n    coroutine.wrap(function ()\r\n      local success, failure = xpcall(function ()\r\n        local dsocket\r\n        if options.tls then\r\n          if not secureSocket then secureSocket = Import(\"ga.duacord.http.Libraries.secure-socket.init\") end\r\n          dsocket = assert(secureSocket(socket, options.tls))\r\n          dsocket.socket = socket\r\n        else\r\n          dsocket = socket\r\n        end\r\n\r\n        local read, write = wrapStream(dsocket)\r\n        local updateDecoder, updateEncoder\r\n        if options.scan then\r\n          -- TODO: should we expose updateScan somehow?\r\n          read = merger(read, options.scan)\r\n        end\r\n        if options.decoder then\r\n          read, updateDecoder = decoder(read, options.decoder())\r\n        elseif options.decode then\r\n          read, updateDecoder = decoder(read, options.decode)\r\n        end\r\n        if options.encoder then\r\n          write, updateEncoder = encoder(write, options.encoder())\r\n        elseif options.encode then\r\n          write, updateEncoder = encoder(write, options.encode)\r\n        end\r\n\r\n        return onConnect(read, write, dsocket, updateDecoder, updateEncoder)\r\n      end, debug.traceback)\r\n      if not success then\r\n        print(failure)\r\n      end\r\n    end)()\r\n  end))\r\n  return server\r\nend\r\n\r\nreturn {\r\n  makeCallback = makeCallback,\r\n  connect = connect,\r\n  createServer = createServer,\r\n}"},"PackageInfo":{"Contact":{"Source":"https://github.com/Dot-lua/Dotter-Project-Template","Website":"http://cubic-inc.nl","Socials":{"Facebook":"","Discord":"https://join.cubic-inc.nl","Twitter":""}},"InfoVersion":1,"Version":"1.0.0","Description":"The Duacord http helper","ID":"http-helper","Author":{"Developers":["CoreByte"],"Contributors":["Dotter Team"]},"Icon":"","Entrypoints":{"Main":"ga.duacord.http.Test"},"Dependencies":{"Dua":[],"Luvit":[]},"Name":"Http"},"Resources":[]}